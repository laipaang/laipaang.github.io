<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LeetCode 650. 只有两个键的键盘</title>
    <url>/posts/2-keys-keyboard/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/2-keys-keyboard/">650. 只有两个键的键盘</a></p>
<p>最初记事本上只有一个字符 'A' 。你每次可以对这个记事本进行两种操作：<br />
<span id="more"></span> Copy All（复制全部）：复制这个记事本中的所有字符（不允许仅复制部分字符）。<br />
Paste（粘贴）：粘贴 上一次 复制的字符。<br />
给你一个数字 n ，你需要使用最少的操作次数，在记事本上输出 恰好 n 个 'A' 。返回能够打印出 n 个 'A' 的最少操作次数。</p>
<h3 id="思路">思路</h3>
<p>1个 次数0<br />
2个 次数2（复制 粘贴）<br />
3个 次数3 (复制 粘贴 粘贴) 4个 次数4 (复制 粘贴*3) 或 (复制 粘贴 复制 粘贴)<br />
...<br />
以直觉来看，我们复制粘贴时基数约大，速度越快（次数越少），同时由于不能复制部分，所以需要考虑整除<br />
这道题成为因子分解题</p>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minSteps</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; i*i&lt;=n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 第一个i是minSteps(i)，由于i已经不能分解minStep(i) == i</span></span><br><span class="line">            <span class="keyword">return</span> i + <span class="built_in">minSteps</span>(n/i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 16. 三数之和</title>
    <url>/posts/3sum/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode.cn/problems/3sum/">16. 三数之和</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。 <span id="more"></span></p>
<h3 id="题解">题解</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    std::<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// O(nlog(n))</span></span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); ++i) &#123; <span class="comment">// O(n^2)</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) &#123; <span class="comment">// avoid duplicate</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> target = -nums[i];</span><br><span class="line">        <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; i+<span class="number">1</span> &amp;&amp; nums[j] == nums[j<span class="number">-1</span>]) &#123; avoid duplicate</span><br><span class="line">                ++j;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> sum = nums[j] + nums[k];</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                --k;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(&#123;nums[i], nums[j], nums[k]&#125;);</span><br><span class="line"></span><br><span class="line">                ++j;</span><br><span class="line">                --k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 122. 买卖股票的最佳时机II</title>
    <url>/posts/best-time-to-buy-and-sell-stock-ii/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机II</a> <code>中等</code></p>
<p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。 <span id="more"></span></p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p><strong>注意</strong>：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<h3 id="思路">思路</h3>
<p>低买入、高抛出</p>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> h = prices.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 低买</span></span><br><span class="line">        <span class="keyword">auto</span> l = std::<span class="built_in">is_sorted_until</span>(h, prices.<span class="built_in">end</span>(), [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a &gt; b;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (l == prices.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 高抛</span></span><br><span class="line">        h = std::<span class="built_in">is_sorted_until</span>(l, prices.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利润</span></span><br><span class="line">        sum += *(h<span class="number">-1</span>) - *(l<span class="number">-1</span>); <span class="comment">// 注意l和h都是实际低点和高点的后一位</span></span><br><span class="line">        h -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>买卖股票</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2. 两数相加</title>
    <url>/posts/add-two-numbers/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。 <span id="more"></span></p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<h3 id="题解">题解</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode head;</span><br><span class="line">        ListNode* p = &amp;head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 || l2) &#123;</span><br><span class="line">            p-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">            <span class="keyword">int</span> val1 = l1 ? l1-&gt;val : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> val2 = l2 ? l2-&gt;val : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> x = val1 + val2 + carry;</span><br><span class="line">            </span><br><span class="line">            p-&gt;next-&gt;val = x % <span class="number">10</span>;</span><br><span class="line">            carry = x / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            l1 = l1 ? l1-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">            l2 = l2 ? l2-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (carry) &#123;</span><br><span class="line">            p-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(carry);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 121. 买卖股票的最佳时机</title>
    <url>/posts/best-time-to-buy-and-sell-stock/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a> <code>简单</code></p>
<p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。 <span id="more"></span></p>
<p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p>
<h3 id="思路">思路</h3>
<p>从左往右扫描，不断更新最低价格、最大收益</p>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> low = prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> pro = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;prices.<span class="built_in">size</span>(); ++ i) &#123;</span><br><span class="line">        low = std::<span class="built_in">min</span>(low, prices[i]);</span><br><span class="line">        pro = std::<span class="built_in">max</span>(pro, prices[i] - low);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pro;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>买卖股票</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 704. 二分查找</title>
    <url>/posts/binary-search/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a>  难度: <span style="color: rgba(90, 183, 38, 1);">简单</span></p>
<p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 <span id="more"></span></p>
<h3 id="题解">题解</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[m] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[m] &lt; target) &#123;</span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = m - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 94. 二叉树的中序遍历</title>
    <url>/posts/binary-tree-inorder-traversal/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给定一个二叉树的根节点 root ，返回它的 中序 遍历。 <span id="more"></span></p>
<h3 id="题解">题解</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorderTraversal</span><span class="params">(TreeNode* root, std::vector&lt;<span class="keyword">int</span>&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">inorderTraversal</span>(root-&gt;left, ans);</span><br><span class="line">    ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    <span class="built_in">inorderTraversal</span>(root-&gt;right, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">inorderTraversal</span>(root, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二叉树遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 103. 二叉树的锯齿形层序遍历</title>
    <url>/posts/binary-tree-zigzag-level-order-traversal/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 <span id="more"></span></p>
<h3 id="题解">题解</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">    std::queue&lt;TreeNode*&gt; q;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> toggle = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=q.<span class="built_in">size</span>(); i&gt;<span class="number">0</span>; --i) &#123;</span><br><span class="line">            TreeNode* p = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            v.<span class="built_in">push_back</span>(p-&gt;val);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (toggle) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;right) q.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;left) q.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;left) q.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;right) q.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(v));</span><br><span class="line">        toggle = !toggle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 102. 二叉树的层序遍历</title>
    <url>/posts/binary-tree-level-order-traversal/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a> 给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。 <span id="more"></span></p>
<h3 id="思路">思路</h3>
<p>广度优先搜索即可，其中关键点如何区分不同层，有两种方法：</p>
<ul>
<li>两个队列区分，一个当前的层，一个接下来的层</li>
<li>记录当前层的节点个数n，不断按n遍历（本文实现）</li>
</ul>
<p>c++有三种容器适配器：std::stack、std::queue、std::priority_queue std::queue队列适配器，FIFO。方法有：<br />
empty()<br />
size()<br />
front()<br />
back()<br />
push(const T&amp; obj)<br />
push(T&amp;&amp; obj)<br />
emplace()<br />
pop()<br />
满足条件的基础容器有std::dequeue、std::list。默认使用的基础容器std::dequeue。</p>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt; vv;</span><br><span class="line">    std::queue&lt;TreeNode*&gt; q;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        vv.<span class="built_in">push_back</span>(&#123;&#125;);</span><br><span class="line">        <span class="keyword">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> n = q.<span class="built_in">front</span>();</span><br><span class="line">            vv.<span class="built_in">back</span>().<span class="built_in">push_back</span>(n-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (n-&gt;left) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(n-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (n-&gt;right) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(n-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> vv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>广度优先搜索</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1117. H2O 生成</title>
    <url>/posts/building-h2o/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode.cn/problems/building-h2o/">1117. H2O 生成</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>现在有两种线程，氧 oxygen 和氢 hydrogen，你的目标是组织这两种线程来产生水分子。</p>
<p>存在一个屏障（barrier）使得每个线程必须等候直到一个完整水分子能够被产生出来。 <span id="more"></span></p>
<p>氢和氧线程会被分别给予 releaseHydrogen 和 releaseOxygen 方法来允许它们突破屏障。</p>
<p>这些线程应该三三成组突破屏障并能立即组合产生一个水分子。</p>
<p>你必须保证产生一个水分子所需线程的结合必须发生在下一个水分子产生之前。</p>
<p>换句话说:</p>
<p>如果一个氧线程到达屏障时没有氢线程到达，它必须等候直到两个氢线程到达。 如果一个氢线程到达屏障时没有其它线程到达，它必须等候直到一个氧线程和另一个氢线程到达。 书写满足这些限制条件的氢、氧线程同步代码。</p>
<h3 id="题解">题解</h3>
<p>不知道对不对，反正AC了，先放在这儿吧，以后回过头再看看。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">H2O</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">H2O</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hydrogen</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; releaseHydrogen)</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">l</span><span class="params">(h_m)</span></span>;</span><br><span class="line">            h_cv.<span class="built_in">wait</span>(l, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">                <span class="keyword">return</span> h_c &lt; <span class="number">2</span>;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            ++h_c;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">releaseHydrogen</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lw</span><span class="params">(w_m)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (h_c + o_c == <span class="number">3</span>) &#123;</span><br><span class="line">            h_c = <span class="number">0</span>;</span><br><span class="line">            o_c = <span class="number">0</span>;</span><br><span class="line">            o_cv.<span class="built_in">notify_all</span>();</span><br><span class="line">            h_cv.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">oxygen</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; releaseOxygen)</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">l</span><span class="params">(o_m)</span></span>;</span><br><span class="line">            o_cv.<span class="built_in">wait</span>(l, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">                <span class="keyword">return</span> o_c &lt; <span class="number">1</span>;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            ++o_c;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">releaseOxygen</span>();</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lw</span><span class="params">(w_m)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (h_c + o_c == <span class="number">3</span>) &#123;</span><br><span class="line">                h_c = <span class="number">0</span>;</span><br><span class="line">                o_c = <span class="number">0</span>;</span><br><span class="line">                o_cv.<span class="built_in">notify_all</span>();</span><br><span class="line">                h_cv.<span class="built_in">notify_all</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> h_c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> o_c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    std::condition_variable h_cv;</span><br><span class="line">    std::condition_variable o_cv;</span><br><span class="line"></span><br><span class="line">    std::mutex h_m;</span><br><span class="line">    std::mutex o_m;</span><br><span class="line">    std::mutex w_m;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 322. 零钱兑换</title>
    <url>/posts/coin-change/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/coin-change/">322. 零钱兑换</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。 <span id="more"></span> 计算并返回可以凑成总金额所需的 <code>最少的硬币个数</code> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<h3 id="思路">思路</h3>
<p>动态规划 <span class="math display">\[
\begin{equation}
    F(i)=\min\limits_{j=0...n-1} F(i-c_j)_{(i-c_j)\geq0} +1
\end{equation}
\]</span></p>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;dp.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;coins.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = i - coins[j];</span><br><span class="line">            <span class="keyword">if</span> (k&lt;<span class="number">0</span> || dp[k]&lt;<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dp[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i] = dp[k];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i] = std::<span class="built_in">min</span>(dp[i], dp[k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] != <span class="number">-1</span>) &#123;</span><br><span class="line">            dp[i] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>背包问题</tag>
        <tag>完全背包</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 312. 戳气球</title>
    <url>/posts/burst-balloons/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/burst-balloons/">312. 戳气球</a> 难度: <span style="color: rgba(239, 71, 67, 1);">困难</span></p>
<p>有 <code>n</code> 个气球，编号为 <code>0</code> 到 <code>n - 1</code>，每个气球上都标有一个数字，这些数字存在数组 <code>nums</code> 中。 <span id="more"></span></p>
<p>现在要求你戳破所有的气球。戳破第 <code>i</code> 个气球，你可以获得 <code>nums[i - 1] * nums[i] * nums[i + 1]</code> 枚硬币。 这里的 <code>i - 1</code> 和 <code>i + 1</code> 代表和 <code>i</code> 相邻的两个气球的序号。如果 <code>i - 1</code> 或 <code>i + 1</code> 超出了数组的边界，那么就当它是一个数字为 <code>1</code> 的气球。</p>
<p>求所能获得硬币的最大数量。</p>
<h3 id="思路">思路</h3>
<h4 id="回溯">回溯</h4>
<p>由于每次戳破一个气球，两个不相邻的气球就会变成相邻，需要维护状态。我们从最终状态，倒放到初始状态，也就是不断的插入气球，直到气球插满。</p>
<p>为了方便，在数组首尾分别添加一个数字为 <code>1</code> 的气球。在两个气球 <code>[i, j]</code> 间 <code>k</code> 插入一个气球，得分 <code>nums[i] * nums[k] * nums[j]</code>，todo</p>
<h4 id="动态规划">动态规划</h4>
<p>todo</p>
<h3 id="实现">实现</h3>
<h4 id="回溯-1">回溯</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">padded_nums</span><span class="params">(n + <span class="number">2</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">            padded_nums[i+<span class="number">1</span>] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">sovled</span>(n+<span class="number">2</span>, std::vector&lt;<span class="keyword">int</span>&gt;(n+<span class="number">2</span>, <span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sovle</span>(padded_nums, sovled, <span class="number">0</span>, n+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sovled[<span class="number">0</span>][n+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sovle</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; nums, std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; sovled, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &gt;= j) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sovled[i][j] != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sovled[i][j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=i+<span class="number">1</span>; k&lt;j; ++k) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = nums[i] * nums[k] * nums[j];</span><br><span class="line">            sum = <span class="built_in">sovle</span>(nums, sovled, i, k) + sum + <span class="built_in">sovle</span>(nums, sovled, k, j);</span><br><span class="line">            sovled[i][j] = std::<span class="built_in">max</span>(sovled[i][j], sum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sovled[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="动态规划-1">动态规划</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">padded_nums</span><span class="params">(n + <span class="number">2</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">        padded_nums[i+<span class="number">1</span>] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">2</span>, std::vector&lt;<span class="keyword">int</span>&gt;(n+<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">2</span>; j&lt;n+<span class="number">2</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k=i+<span class="number">1</span>; k&lt;j; ++k) &#123;</span><br><span class="line">                <span class="keyword">int</span> s = dp[i][k] + padded_nums[i] * padded_nums[k] * padded_nums[j] + dp[k][j];</span><br><span class="line">                dp[i][j] = std::<span class="built_in">max</span>(dp[i][j], s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>回溯</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 39. 组合总和</title>
    <url>/posts/combination-sum/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a> <code>中等</code></p>
<p>给定一个<strong>无重复元素</strong>的正整数数组 <code>candidates</code> 和一个正整数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为目标数<code>target</code> 的唯一组合。 <span id="more"></span></p>
<p><code>candidates</code> 中的数字可以无限制重复被选取。如果至少一个所选数字数量不同，则两种组合是唯一的。 </p>
<p>对于给定的输入，保证和为 <code>target</code> 的唯一组合数少于 <code>150</code> 个。</p>
<h3 id="思路">思路</h3>
<p>深度优先搜索，可在某些情况下剪枝</p>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> pos, std::vector&lt;<span class="keyword">int</span>&gt; combs,std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(combs);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    combs.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=pos; i&lt;candidates.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="comment">// 剪枝</span></span><br><span class="line">        <span class="keyword">if</span> (target &lt; candidates[i]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        combs.<span class="built_in">back</span>() = candidates[i];</span><br><span class="line">        <span class="built_in">dfs</span>(candidates, target - candidates[i], i, combs, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(std::vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>()); <span class="comment">// 可剪枝的前置条件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;candidates.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; candidates[i]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(candidates, target - candidates[i], i, &#123;candidates[i]&#125;, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>回溯</tag>
        <tag>深度优先搜索</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>读过的书籍</title>
    <url>/posts/books-read/</url>
    <content><![CDATA[<h4 id="section">2022</h4>
<ul>
<li>《生命是什么》 王立铭</li>
<li>《时间的秩序》 卡洛·罗韦利</li>
<li>《哲学家都干了些什么》 林欣浩</li>
<li>《刀锋》 毛姆</li>
</ul>
<span id="more"></span>
<h4 id="section-1">2021</h4>
<ul>
<li>《李光耀观天下（精装版）》 李光耀</li>
<li>《以色列-一个民族的重生》 丹尼尔·戈迪斯</li>
<li>《耶路撒冷3000年》 西蒙·蒙蒂菲奥里</li>
<li>《简明美国史》 陈勤</li>
</ul>
<h4 id="section-2">2020</h4>
<ul>
<li>《祖先》 田森垚</li>
<li>《祖先II》 田森垚</li>
<li>《深度学习》 斋藤康毅</li>
<li>《动物凶猛》 王朔</li>
<li>《爱你就像爱生命》 王小波</li>
</ul>
<h4 id="section-3">2019</h4>
<ul>
<li>《史蒂夫·乔布斯传》 沃尔特·艾萨克森</li>
<li>《月亮与六便士》 毛姆</li>
<li>《围城》 钱钟书</li>
<li>《双城记》 查尔斯·狄更斯</li>
<li>《步履不停》 是枝裕和</li>
<li>《简明日本史》 陈勤</li>
<li>《邓小平时代》 傅高义</li>
</ul>
<h4 id="b4">B4</h4>
<ul>
<li>《边城》 沈从文</li>
<li>《伊豆舞女》 川端康成</li>
<li>《千纸鹤》 川端康成</li>
<li>《平凡的世界》 路遥</li>
<li></li>
</ul>
]]></content>
      <tags>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1446. 连续字符</title>
    <url>/posts/consecutive-characters/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/consecutive-characters/">1446. 连续字符</a>  难度: <span style="color: rgba(90, 183, 38, 1);">简单</span></p>
<p>给你一个字符串 s ，字符串的「能量」定义为：只包含一种字符的最长非空子字符串的长度。</p>
<p>请你返回字符串的能量。 <span id="more"></span></p>
<h3 id="题解">题解</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxPower</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max_len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt_len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] != s[i<span class="number">-1</span>]) &#123;</span><br><span class="line">            max_len = std::<span class="built_in">max</span>(max_len, cnt_len);</span><br><span class="line">            cnt_len = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ++cnt_len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    max_len = std::<span class="built_in">max</span>(max_len, cnt_len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 338. 比特位计数</title>
    <url>/posts/counting-bits/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/counting-bits/">543. 二叉树的直径</a>  难度: <span style="color: rgba(90, 183, 38, 1);">简单</span></p>
<span id="more"></span>
<h3 id="思路">思路</h3>
<p>todo</p>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x = i;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = x &amp; (x<span class="number">-1</span>);</span><br><span class="line">            ++c;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans.<span class="built_in">push_back</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i) &#123;</span><br><span class="line">        ans[i] = ans[i &amp; (i<span class="number">-1</span>)] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 11. 盛水最多的容器</title>
    <url>/posts/container-with-most-water/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/container-with-most-water/">11. 盛水最多的容器</a> <code>中等</code></p>
<p>给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。 <span id="more"></span> 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>说明：你不能倾斜容器。</p>
<h3 id="思路">思路</h3>
<p>双指针，分别指向首尾，向中间遍历，每次移动数值小的索引</p>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max_area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (r &gt; l) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur_area = std::<span class="built_in">min</span>(height[l], height[r]) * (r - l);</span><br><span class="line">        max_area = std::<span class="built_in">max</span>(max_area, cur_area);</span><br><span class="line">        <span class="keyword">if</span> (height[l] &gt; height[r]) &#123;</span><br><span class="line">            --r;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ++l;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max_area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 859. 亲密字符串</title>
    <url>/posts/buddy-strings/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/buddy-strings/">859. 亲密字符串</a>  难度: <span style="color: rgba(90, 183, 38, 1);">简单</span></p>
<p>给你两个字符串 <code>s</code> 和 <code>goal</code> ，只要我们可以通过交换 <code>s</code> 中的两个字母得到与 <code>goal</code> 相等的结果，就返回 <code>true</code> ；否则返回 <code>false</code> 。 <span id="more"></span></p>
<p>交换字母的定义是：取两个下标 <code>i</code> 和 <code>j</code> （下标从 <code>0</code> 开始）且满足 <code>i != j</code> ，接着交换 <code>s[i]</code> 和 <code>s[j]</code> 处的字符。</p>
<p>例如，在 <code>"abcd"</code> 中交换下标 <code>0</code> 和下标 <code>2</code> 的元素可以生成 <code>"cbad"</code> 。</p>
<h3 id="解法">解法</h3>
<p>需要分情况考虑。</p>
<p>一、当两个字符串相等时，只要字符串中存在重复字符，将重复字符交换即符合条件。</p>
<p>二、当两个字符串不相等时，我们只需要找到两个不相等的下标 <code>i</code> <code>j</code>，两个下标外部分都相等，且 <code>s[i] == goal[j] &amp;&amp; s[j] == goal[i]</code></p>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">buddyStrings</span><span class="params">(std::string s, std::string goal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() != goal.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s == goal) &#123;</span><br><span class="line">        <span class="comment">// 由于是26个小写字母 也可通过std::vector&lt;int&gt; h(26, 0)作为哈希表</span></span><br><span class="line">        std::unordered_set&lt;<span class="keyword">char</span>&gt; x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            x.<span class="built_in">insert</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x.<span class="built_in">size</span>() != s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; s.<span class="built_in">size</span>(); ++k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[k] != goal[k]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                i = k;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                j = k;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s[i] != goal[j] || s[j] != goal[i]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 207. 课程表</title>
    <url>/posts/course-schedule/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/course-schedule/">207. 课程表</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>你这个学期必须选修 <code>numCourses</code> 门课程，记为 <code>0</code> 到 <code>numCourses - 1</code> 。 <span id="more"></span></p>
<p>在选修某些课程之前需要一些先修课程。 先修课程按数组 <code>prerequisites</code> 给出，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示如果要学习课程 <code>ai</code> 则 <code>必须</code> 先学习课程  <code>bi</code> 。</p>
<p>例如，先修课程对 <code>[0, 1]</code> 表示：想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> 。 请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<h3 id="思路">思路</h3>
<p>所有课程是节点，先后课程构成有向边，是一个图问题。明显当图中存在环时不能完成所有课程。判断是否存在环可以通过深度优先遍历，当一个节点回溯前被再次遍历到说明存在环。</p>
<p>这个问题的另一个解法是通过广度优先遍历进行拓扑排序。思路如下：</p>
<ol type="1">
<li>选择一个入度为0的节点。</li>
<li>将该节点和它连接的边删除。</li>
<li>不断重复1，2，直到找不到入度为0的节点。</li>
</ol>
<p>结束时，如果存在未遍历的节点，那么一定是存在环的。</p>
<h3 id="实现">实现</h3>
<h4 id="广度优先遍历">广度优先遍历</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::unordered_set&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">in_out</span>(numCourses);</span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">in_deg</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>; <span class="comment">// 节点入度统计</span></span><br><span class="line">    std::queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v: prerequisites) &#123;</span><br><span class="line">        in_out[v[<span class="number">0</span>]].<span class="built_in">insert</span>(v[<span class="number">1</span>]);</span><br><span class="line">        ++in_deg[v[<span class="number">1</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numCourses; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (in_deg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bfs</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> j: in_out[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--in_deg[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt == numCourses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="深度优先遍历">深度优先遍历</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; visited; <span class="comment">// 0:not visit 1:visiting 2:visited</span></span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt; in_out;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 深度优先遍历到 `遍历中` 的节点说明存在环</span></span><br><span class="line">        <span class="keyword">if</span> (visited[i] == <span class="number">1</span>) &#123;</span><br><span class="line">            valid = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (visited[i] == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        visited[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> j: in_out[i]) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(j);</span><br><span class="line">            <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        visited[i] = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        visited.<span class="built_in">resize</span>(numCourses, <span class="number">0</span>);</span><br><span class="line">        in_out.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        valid = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v: prerequisites) &#123;</span><br><span class="line">            in_out[v[<span class="number">0</span>]].<span class="built_in">push_back</span>(v[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>深度优先</tag>
        <tag>广度优先</tag>
        <tag>拓补排序</tag>
        <tag>图</tag>
        <tag>课程表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 538. 把二叉搜索树转换为累加树</title>
    <url>/posts/convert-bst-to-greater-tree/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。 <span id="more"></span></p>
<p>提醒一下，二叉搜索树满足下列约束条件：</p>
<p>节点的左子树仅包含键 小于 节点键的节点。 节点的右子树仅包含键 大于 节点键的节点。 左右子树也必须是二叉搜索树。</p>
<h3 id="题解">题解</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">right_to_left</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; acc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">right_to_left</span>(root-&gt;right, acc);</span><br><span class="line">        acc += root-&gt;val;</span><br><span class="line">        root-&gt;val = acc;</span><br><span class="line">        <span class="built_in">right_to_left</span>(root-&gt;left, acc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> acc = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">right_to_left</span>(root, acc);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二叉树遍历</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 394. 字符串解码</title>
    <url>/posts/decode-string/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode.cn/problems/decode-string/">394. 字符串解码</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给定一个经过编码的字符串，返回它解码后的字符串。</p>
<p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。 <span id="more"></span></p>
<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>
<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p>
<h3 id="题解">题解</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">expand</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">char</span>** endstr, <span class="keyword">int</span>&amp; len, <span class="keyword">char</span>* buff)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (*str) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*str == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">                ++str; <span class="comment">// skip &#x27;]&#x27;</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (std::<span class="built_in">isdigit</span>(*str)) &#123;</span><br><span class="line">                k = std::<span class="built_in">strtol</span>(str, &amp;str, <span class="number">10</span>);</span><br><span class="line">                ++str; <span class="comment">// skip &#x27;[&#x27;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 1. 将括号中的展开，buff</span></span><br><span class="line">                n = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">expand</span>(str, endstr, n, buff);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2. 重复k-1次括号中的内容，步骤1中展开已经有1次了</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k<span class="number">-1</span>; ++i) &#123;</span><br><span class="line">                    std::<span class="built_in">memcpy</span>(buff+n, buff, n);</span><br><span class="line">                    buff += n;</span><br><span class="line">                &#125;</span><br><span class="line">                buff += n;</span><br><span class="line"></span><br><span class="line">                len += k*n;</span><br><span class="line">                str = *endstr;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// just copy</span></span><br><span class="line">                *buff++ = *str++;</span><br><span class="line">                ++len;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *endstr = str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">decodeString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> buff[<span class="number">4096</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">char</span>* str = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(s.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">char</span>* endstr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">expand</span>(str, &amp;endstr, n, buf);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">string</span>(buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 739. 每日温度</title>
    <url>/posts/daily-temperatures/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/daily-temperatures/">739. 每日温度</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>请根据每日 <code>气温</code> 列表 <code>temperatures</code> ，请计算在每一天需要等几天才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。 <span id="more"></span></p>
<h3 id="思路">思路</h3>
<h4 id="暴力搜">暴力搜</h4>
<p>对于每个元素，向后搜索第一个比它大的值，计算两者的距离。时间复杂度 O(n^2)</p>
<h4 id="单调栈">单调栈</h4>
<p>维护一个存放下标的栈，栈底到栈顶对应的温度单调递减。我们从后向前遍历元素，对于每个元素：</p>
<ul>
<li>如果栈不为空，不断弹出栈中的值，直到对应的温度大于当前值，两者距离即是该元素的解</li>
<li>如果栈为空，那么说明原数组中它后面不存在比它高的温度，元素解为 <code>0</code></li>
<li>当前元素入栈</li>
</ul>
<p>由于，我们弹出的是比当前元素小的值，不用担心后面遍历元素的解被弹出。</p>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(temperatures.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=temperatures.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; temperatures[s.<span class="built_in">top</span>()] &lt;= temperatures[i]) &#123;</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        ans[i] = s.<span class="built_in">empty</span>() ? <span class="number">0</span> : s.<span class="built_in">top</span>() - i;</span><br><span class="line"></span><br><span class="line">        s.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 138. 复制带随机指针的链表</title>
    <url>/posts/copy-list-with-random-pointer/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/add-two-numbers/">138. 复制带随机指针的链表</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。 <span id="more"></span></p>
<p>构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。</p>
<p>例如，如果原链表中有 X 和 Y 两个节点，其中 X.random --&gt; Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random --&gt; y 。</p>
<p>返回复制链表的头节点。</p>
<p>用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：</p>
<p>val：一个表示 Node.val 的整数。 random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。 你的代码 只 接受原链表的头节点 head 作为传入参数。</p>
<h3 id="题解">题解</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> it = mem.<span class="built_in">find</span>(head);</span><br><span class="line">        <span class="keyword">if</span> (it == mem.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            Node* n = <span class="keyword">new</span> <span class="built_in">Node</span>(head-&gt;val);</span><br><span class="line">            mem.<span class="built_in">insert</span>(&#123;head, n&#125;);</span><br><span class="line">            n-&gt;next = <span class="built_in">copyRandomList</span>(head-&gt;next);</span><br><span class="line">            n-&gt;random = <span class="built_in">copyRandomList</span>(head-&gt;random);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::unordered_map&lt;Node*, Node*&gt; mem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node* p = head;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        Node* n = <span class="keyword">new</span> <span class="built_in">Node</span>(p-&gt;val);</span><br><span class="line">        n-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = n;</span><br><span class="line">        p = n-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p = head;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;random) &#123;</span><br><span class="line">            p-&gt;next-&gt;random = p-&gt;random-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node <span class="title">n</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    p = &amp;n;</span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">        p-&gt;next = head-&gt;next;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        head-&gt;next = head-&gt;next-&gt;next;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 543. 二叉树的直径</title>
    <url>/posts/diameter-of-binary-tree/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">543. 二叉树的直径</a>  难度: <span style="color: rgba(90, 183, 38, 1);">简单</span></p>
<span id="more"></span>
<h3 id="解法">解法</h3>
<p>todo</p>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; diameter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = root-&gt;left ? <span class="built_in">depth</span>(root-&gt;left, diameter) + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = root-&gt;right ? <span class="built_in">depth</span>(root-&gt;right, diameter) + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        diameter = std::<span class="built_in">max</span>(diameter, l + r);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">max</span>(l, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> diameter = std::numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line">        <span class="built_in">depth</span>(root, diameter);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> diameter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</title>
    <url>/posts/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">21. 调整数组顺序使奇数位于偶数前面</a>  难度: <span style="color: rgba(90, 183, 38, 1);">简单</span></p>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。</p>
<span id="more"></span>
<h3 id="题解">题解</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">exchange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n; ++k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[k] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            ans[j--] = nums[k];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans[i++] = nums[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 72. 编辑距离</title>
    <url>/posts/edit-distance/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/edit-distance/">72. 编辑距离</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给你两个单词 <code>word1</code> 和 <code>word2</code>，请你计算出将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数 。</p>
<span id="more"></span>
<p>你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<h3 id="思路">思路</h3>
<p>动态规划 <span class="math display">\[
\begin{equation}
    lev_{a,b}(i,j)=\begin{cases}
    max(i,j) &amp;  \text{if }min(i,j) = 0, \\
    \\
    min\begin{cases}
    lev_{a,b}(i-1,j) + 1 \\
    lev_{a,b}(i,j-1) + 1 \\
    lev_{a,b}(i-1,j-1) + 1_{a_i \neq b_j} 
    \end{cases}
    &amp;  \text{otherwise}.
    \end{cases}
\end{equation}
\]</span> 其中，<span class="math inline">\(0\le i\le|a|,\text{ } 0\le j\le|b|\)</span></p>
<p>todo</p>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(std::string word1, std::string word2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = word1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> len2 = word2.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len1*len2 == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> len1 + len2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(len1+<span class="number">1</span>, std::vector&lt;<span class="keyword">int</span>&gt;(len2+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=len1; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=len2; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (std::<span class="built_in">min</span>(i, j) == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = std::<span class="built_in">max</span>(i, j);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 注意i和j转成字符下标需要减1</span></span><br><span class="line">                <span class="keyword">int</span> d = word1[i<span class="number">-1</span>] != word2[j<span class="number">-1</span>] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                dp[i][j] = std::<span class="built_in">min</span>(&#123;dp[i<span class="number">-1</span>][j]+<span class="number">1</span>, dp[i][j<span class="number">-1</span>]+<span class="number">1</span>, dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+d&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>编辑距离</tag>
        <tag>莱文斯坦（Levenshtein）距离</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 535. TinyURL 的加密与解密</title>
    <url>/posts/encode-and-decode-tinyurl/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode.cn/problems/encode-and-decode-tinyurl/">535. TinyURL 的加密与解密</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>TinyURL 是一种 URL 简化服务， 比如：当你输入一个 URL https://leetcode.com/problems/design-tinyurl 时，它将返回一个简化的URL http://tinyurl.com/4e9iAk 。请你设计一个类来加密与解密 TinyURL 。 <span id="more"></span></p>
<p>加密和解密算法如何设计和运作是没有限制的，你只需要保证一个 URL 可以被加密成一个 TinyURL ，并且这个 TinyURL 可以用解密方法恢复成原本的 URL 。</p>
<p>实现 Solution 类：</p>
<p>Solution() 初始化 TinyURL 系统对象。 String encode(String longUrl) 返回 longUrl 对应的 TinyURL 。 String decode(String shortUrl) 返回 shortUrl 原本的 URL 。题目数据保证给定的 shortUrl 是由同一个系统对象加密的。</p>
<h3 id="题解">题解</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a URL to a shortened URL.</span></span><br><span class="line">    <span class="function">string <span class="title">encode</span><span class="params">(string longUrl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">size_t</span> pos = longUrl.<span class="built_in">find_last_of</span>(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        std::string hash = std::<span class="built_in">to_string</span>(_hash(longUrl.<span class="built_in">substr</span>(pos+<span class="number">1</span>)));</span><br><span class="line">        std::string shortUrl = longUrl.<span class="built_in">substr</span>(<span class="number">0</span>, pos+<span class="number">1</span>) + hash;</span><br><span class="line">        _map.<span class="built_in">insert</span>(&#123;shortUrl, longUrl&#125;);      </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> shortUrl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes a shortened URL to its original URL.</span></span><br><span class="line">    <span class="function">string <span class="title">decode</span><span class="params">(string shortUrl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _map[shortUrl];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::hash&lt;std::string&gt; _hash;</span><br><span class="line">    std::unordered_map&lt;std::string, std::string&gt; _map;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Solution solution;</span></span><br><span class="line"><span class="comment">// solution.decode(solution.encode(url));</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>断言</title>
    <url>/posts/enforce/</url>
    <content><![CDATA[<p>通过宏实现一个简单断言<code>ENFORCE</code>，不成立时打印错误后抛异常</p>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIKELY(x) __builtin_expect(!!(x), 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNLIKELY(x) __builtin_expect(!!(x), 0)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;class... Args&gt;</span><br><span class="line"><span class="function">std::string <span class="title">ParserFormat</span><span class="params">(<span class="keyword">const</span> std::string&amp; format=<span class="string">&quot;&quot;</span>, <span class="keyword">const</span> Args &amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    std::<span class="built_in">snprintf</span>(buf, <span class="number">1024</span>, format.<span class="built_in">c_str</span>(), args...);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParserException</span> :</span> <span class="keyword">public</span> std::exception &#123;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">what</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;ParserException&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENFORCE(COND, ...)                                                      \</span></span><br><span class="line"><span class="meta">  do &#123;                                                                          \</span></span><br><span class="line"><span class="meta">    auto __cond__ = (COND);                                                     \</span></span><br><span class="line"><span class="meta">    <span class="meta-keyword">if</span> (UNLIKELY(!(__cond__))) &#123;                                                \</span></span><br><span class="line"><span class="meta">      std::cerr &lt;&lt; ParserFormat(<span class="meta-string">&quot;ENFORCE FAIL ON File: %s Line: %d Cond: %s\n&quot;</span>, \</span></span><br><span class="line"><span class="meta">                                __FILE__, __LINE__, #COND)                      \</span></span><br><span class="line"><span class="meta">                &lt;&lt; ParserFormat(__VA_ARGS__);                                   \</span></span><br><span class="line"><span class="meta">      throw ParserException();                                                  \</span></span><br><span class="line"><span class="meta">    &#125;                                                                           \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>代码片段</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 399. 除法求值</title>
    <url>/posts/evaluate-division/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/evaluate-division/">399. 除法求值</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给你一个变量对数组 <code>equations</code> 和一个实数值数组 <code>values</code> 作为已知条件，其中 <code>equations[i] = [Ai, Bi]</code> 和 <code>values[i]</code> 共同表示等式 <code>Ai / Bi = values[i]</code> 。每个 <code>Ai</code> 或 <code>Bi</code> 是一个表示单个变量的字符串。 <span id="more"></span></p>
<p>另有一些以数组 <code>queries</code> 表示的问题，其中 <code>queries[j] = [Cj, Dj]</code> 表示第 <code>j</code> 个问题，请你根据已知条件找出 <code>Cj / Dj = ?</code> 的结果作为答案。</p>
<p>返回 <strong>所有问题的答案</strong> 。如果存在某个无法确定的答案，则用 <code>-1.0</code> 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 <code>-1.0</code> 替代这个答案。</p>
<p><strong>注意</strong>：输入总是有效的。你可以假设除法运算中不会出现除数为 <code>0</code> 的情况，且不存在任何矛盾的结果。</p>
<h3 id="解法">解法</h3>
<p>参考官方题解的三种方案：广度优先搜索、Floyd算法、Union-Find。前两种是图的搜索，后一种是集合划分。三种方法的第一步都是将输入转换成符号表(symbol table)，其中，图的搜索需要构建邻接矩阵。</p>
<h4 id="广度优先搜索">广度优先搜索</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="keyword">double</span>&gt; <span class="title">calcEquation</span><span class="params">(std::vector&lt;std::vector&lt;std::string&gt;&gt;&amp; equations, std::vector&lt;<span class="keyword">double</span>&gt;&amp; values, std::vector&lt;std::vector&lt;std::string&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">    std::unordered_map&lt;std::string, <span class="keyword">int</span>&gt; str2num;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;equations.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> it = str2num.<span class="built_in">find</span>(equations[i][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (it == str2num.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            str2num.<span class="built_in">insert</span>(&#123;equations[i][<span class="number">0</span>], num++&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        it = str2num.<span class="built_in">find</span>(equations[i][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (it == str2num.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            str2num.<span class="built_in">insert</span>(&#123;equations[i][<span class="number">1</span>], num++&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::vector&lt;std::pair&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt;&gt;&gt; <span class="built_in">edges</span>(str2num.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;equations.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = str2num[equations[i][<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">int</span> b = str2num[equations[i][<span class="number">1</span>]];</span><br><span class="line">        edges[a].<span class="built_in">push_back</span>(&#123;b, values[i]&#125;);</span><br><span class="line">        edges[b].<span class="built_in">push_back</span>(&#123;a, <span class="number">1.0</span> / values[i]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">double</span>&gt; <span class="title">ans</span><span class="params">(queries.size(), <span class="number">-1.0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;queries.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> it1 = str2num.<span class="built_in">find</span>(queries[i][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">auto</span> it2 = str2num.<span class="built_in">find</span>(queries[i][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (it1 == str2num.<span class="built_in">end</span>() || it2 == str2num.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> a = it1-&gt;second;</span><br><span class="line">        <span class="keyword">int</span> b = it2-&gt;second;</span><br><span class="line"></span><br><span class="line">        std::queue&lt;<span class="keyword">int</span>&gt; q&#123;&#123;a&#125;&#125;;</span><br><span class="line">        <span class="function">std::vector&lt;<span class="keyword">double</span>&gt; <span class="title">nodes</span><span class="params">(edges.size(), <span class="number">-1.0</span>)</span></span>;</span><br><span class="line">        nodes[a] = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            a = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">                ans[i] = nodes[b];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p: edges[a]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nodes[p.first] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    nodes[p.first] = nodes[a] * p.second;</span><br><span class="line">                    q.<span class="built_in">push</span>(p.first);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="floyd算法">Floyd算法</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="keyword">double</span>&gt; <span class="title">calcEquation</span><span class="params">(std::vector&lt;std::vector&lt;std::string&gt;&gt;&amp; equations, std::vector&lt;<span class="keyword">double</span>&gt;&amp; values, std::vector&lt;std::vector&lt;std::string&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">    std::unordered_map&lt;std::string, <span class="keyword">int</span>&gt; str2num;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;equations.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str2num.<span class="built_in">count</span>(equations[i][<span class="number">0</span>]) == <span class="number">0</span>) &#123;</span><br><span class="line">            str2num.<span class="built_in">insert</span>(&#123;equations[i][<span class="number">0</span>], num++&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (str2num.<span class="built_in">count</span>(equations[i][<span class="number">1</span>]) == <span class="number">0</span>) &#123;</span><br><span class="line">            str2num.<span class="built_in">insert</span>(&#123;equations[i][<span class="number">1</span>], num++&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = str2num.<span class="built_in">size</span>();</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="keyword">double</span>&gt;&gt; <span class="built_in">dis</span>(n, std::vector&lt;<span class="keyword">double</span>&gt;(n, <span class="number">-1.0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;equations.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = str2num[equations[i][<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">int</span> b = str2num[equations[i][<span class="number">1</span>]];</span><br><span class="line">        dis[a][b] = values[i];</span><br><span class="line">        dis[b][a] = <span class="number">1.0</span> / values[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// k须放在外层</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n; ++k) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dis[i][k] &gt; <span class="number">0</span> &amp;&amp; dis[k][j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    dis[i][j] = dis[i][k] * dis[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">double</span>&gt; <span class="title">ans</span><span class="params">(queries.size(), <span class="number">-1.0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;queries.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> it1 = str2num.<span class="built_in">find</span>(queries[i][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">auto</span> it2 = str2num.<span class="built_in">find</span>(queries[i][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (it1 == str2num.<span class="built_in">end</span>() || it2 == str2num.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans[i] = dis[it1-&gt;second][it2-&gt;second];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="并查集算法">并查集算法</h4>
<p>在<a href="/posts/union-find">并查集</a>中，实现了带权重的路径和路径压缩。第一次实现时仅仅增加了：</p>
<ul>
<li><code>std::vector&lt;double&gt; ratios;</code></li>
<li><code>double ratio(int i, int j);</code></li>
</ul>
<p>其中，ratio表示的是子节点与父节点比值，在<code>union</code>和<code>ratios</code>方法中需要遍历计算子节点与根节点的比值，再计算子节点间的比值。</p>
<p>后来看官方的解法，并没有 <em>遍历计算子节点与根节点的比值</em> 这一操作。分析其代码才明白：区别在于路径压缩方式的不同，<a href="/posts/union-find">并查集</a>中的压缩是不断将子节点挂在父节点的父节点上，ratios永远表示的节点与父节点的比值；官方解法中的压缩是将整条路径的节点都挂在根节点上，只要经过<code>find</code>操作过的路径上节点，ratios表示的就是节点与根节点的比值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        id.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">            id[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        rank.<span class="built_in">resize</span>(n, <span class="number">1</span>);</span><br><span class="line">        ratios.<span class="built_in">resize</span>(n, <span class="number">1.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unions</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">double</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="built_in">find</span>(i);</span><br><span class="line">        <span class="keyword">int</span> q = <span class="built_in">find</span>(j);</span><br><span class="line">        <span class="keyword">if</span> (p == q) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rank[p] &gt; rank[q]) &#123;</span><br><span class="line">            std::<span class="built_in">swap</span>(p, q);</span><br><span class="line">            std::<span class="built_in">swap</span>(i, j);</span><br><span class="line">            r = <span class="number">1.0</span> / r;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        id[p] = q;</span><br><span class="line">        ++rank[q];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find中的压缩保证i和j都挂在根节点，p/q = i/j * j/q / i/p</span></span><br><span class="line">        ratios[p] = r * ratios[j] / ratios[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面的压缩方式是在递归过程中将路径上的节点都挂在根节点。另外一种压缩方式是自底向上，不断将节点挂在爷爷节点。</span></span><br><span class="line">    <span class="comment">// 前者相比后者，在unions和ratio接口中较容易处理ratios[]。</span></span><br><span class="line">    <span class="comment">// 后者ratios[]中存的是当前节点与父节点的比值，所以需要额外计算当前节点与根节点的比值。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == id[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> j = <span class="built_in">find</span>(id[i]);</span><br><span class="line">        ratios[i] *= ratios[id[i]];<span class="comment">// a-&gt;b-&gt;c : c/a = c/b * b/a</span></span><br><span class="line">        id[i] = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">ratio</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">connected</span>(i, j)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// connected中调用了find，a-&gt;b a-&gt;c: c/b = c/a / b/a</span></span><br><span class="line">        <span class="keyword">return</span> ratios[i] / ratios[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(i) == <span class="built_in">find</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; id;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; rank; <span class="comment">// 秩</span></span><br><span class="line">    std::vector&lt;<span class="keyword">double</span>&gt; ratios; <span class="comment">// 比值 子/根</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="keyword">double</span>&gt; <span class="title">calcEquation</span><span class="params">(std::vector&lt;std::vector&lt;std::string&gt;&gt;&amp; equations, std::vector&lt;<span class="keyword">double</span>&gt;&amp; values, std::vector&lt;std::vector&lt;std::string&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">    std::unordered_map&lt;std::string, <span class="keyword">int</span>&gt; tb; <span class="comment">//  symbol table</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;equations.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; s = equations[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">auto</span>&amp; e = equations[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (tb.<span class="built_in">count</span>(s) == <span class="number">0</span>) &#123;</span><br><span class="line">            tb[s] = n++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tb.<span class="built_in">count</span>(e) == <span class="number">0</span>) &#123;</span><br><span class="line">            tb[e] = n++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n = tb.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">UnionFind <span class="title">uf</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;equations.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = tb[equations[i][<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">int</span> e = tb[equations[i][<span class="number">1</span>]];</span><br><span class="line">        uf.<span class="built_in">unions</span>(s, e, values[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">double</span>&gt; <span class="title">ans</span><span class="params">(queries.size(), <span class="number">-1.0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;queries.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> it1 = tb.<span class="built_in">find</span>(queries[i][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">auto</span> it2 = tb.<span class="built_in">find</span>(queries[i][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (it1 == tb.<span class="built_in">end</span>() || it2 == tb.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans[i] = uf.<span class="built_in">ratio</span>(it1-&gt;second, it2-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>广度优先</tag>
        <tag>图</tag>
        <tag>并查集</tag>
        <tag>Floyd</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客 奇数下标都是奇数或者偶数下标都是偶数</title>
    <url>/posts/exchange-odd-even-number-to-odd-even-index/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://www.nowcoder.com/questionTerminal/335823db14b945ab95241a74cfcf1ae7">牛客 奇数下标都是奇数或者偶数下标都是偶数</a>  难度: <span style="color: rgba(90, 183, 38, 1);">简单</span></p>
<p>给定一个长度不小于2的数组arr，实现一个函数调整arr，要么让所有的偶数下标都是偶数，要么让所有的奇数下标都是奇数 <span id="more"></span></p>
<p><strong>[要求]</strong> 时间复杂度为O(n)，额外空间复杂度为O(1)</p>
<h3 id="题解">题解</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; nums.<span class="built_in">size</span>() &amp;&amp; j &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            j += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        std::<span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">        std::cin &gt;&gt; nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exchange</span>(nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 448. 找到所有数组中消失的数字</title>
    <url>/posts/find-all-numbers-disappeared-in-an-array/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/">448. 找到所有数组中消失的数字</a>  难度: <span style="color: rgba(90, 183, 38, 1);">简单</span></p>
<p>给你一个含 <code>n</code> 个整数的数组 <code>nums</code> ，其中 <code>nums[i]</code> 在区间 <code>[1, n]</code> 内。请你找出所有在 <code>[1, n]</code> 范围内但没有出现在 <code>nums</code> 中的数字，并以数组的形式返回结果。 <span id="more"></span></p>
<p><strong>进阶</strong>：你能在不使用额外空间且时间复杂度为 <code>O(n)</code> 的情况下解决这个问题吗? 你可以假定返回的数组不算在额外空间内。</p>
<h3 id="思路">思路</h3>
<p>将 <code>nums</code> 作为 <code>hash</code> 表，将每个元素 <code>num</code> 放在 <code>num-1</code> 位置。那么，<code>nums</code> 空出的位置对应的就是消失的数字。通过不断交换，将每个元素 <code>num</code> 放在 <code>num-1</code> 索引处，对于空出来的位置填 <code>0</code>。</p>
<p><strong>官方原地修改的解法</strong></p>
<blockquote>
<p>第一次遍历对于每个元素<code>num</code>，对于<code>num-1</code>位置元素加 <code>n</code>（模<code>n</code>防止溢出），再次遍历时那些小于等于 <code>n</code> 的元素位置对应的就是消失的数字</p>
</blockquote>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findDisappearedNumbers</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>();) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == i+<span class="number">1</span> || nums[i] == <span class="number">0</span>) &#123; <span class="comment">// 不需要调整</span></span><br><span class="line">            ++i;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j = nums[i] - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == nums[j]) &#123; <span class="comment">// 再次遇到置为0</span></span><br><span class="line">            nums[i] = <span class="number">0</span>;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::<span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>分桶</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 287. 寻找重复数</title>
    <url>/posts/find-the-duplicate-number/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode.cn/problems/find-the-duplicate-number/">287. 寻找重复数</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。 <span id="more"></span></p>
<p>假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。</p>
<p>你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。</p>
<h3 id="题解">题解</h3>
<p>一、二分查找</p>
<p>抽屉原理：10个苹果放9个抽屉，一定有一个抽屉里有两个苹果。1+n个位置，数值范围1-n，一定存在重复的数。从数值范围1-n进行二分查找，每次范围缩小一半，假设切分点是x，如果整个数组小于等于x的个数大于x，重复的数一定出现在x右侧（包括x）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> r = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 抽屉原理：10个苹果放9个抽屉，一定有一个抽屉里有两个苹果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &lt;= m) &#123;</span><br><span class="line">                ++c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1 1 2</span></span><br><span class="line">        <span class="comment">// 1 2 2</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt; m) &#123;</span><br><span class="line">            r = m;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>位运算</tag>
        <tag>floyd判环</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 34. 在排序数组中查找元素的第一个和最后一个位置</title>
    <url>/posts/find-first-and-last-position-of-element-in-sorted-array/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a> <code>中等</code></p>
<p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p>
<span id="more"></span>
<p>如果数组中不存在目标值 target，返回 [-1, -1]。</p>
<p><strong>进阶：</strong></p>
<p>你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？</p>
<h3 id="思路">思路</h3>
<p>二分查找，<code>&lt;algorithm&gt;</code>提供的函数有： <code>std::equal_range</code></p>
<h4 id="possible-implementation">Possible implementation</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class ForwardIt, class T, class Compare&gt;</span></span><br><span class="line"><span class="function">std::pair&lt;ForwardIt,ForwardIt&gt; </span></span><br><span class="line"><span class="function">    <span class="title">equal_range</span><span class="params">(ForwardIt first, ForwardIt last,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">const</span> T&amp; value, Compare comp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_pair</span>(std::<span class="built_in">lower_bound</span>(first, last, value, comp),</span><br><span class="line">                          std::<span class="built_in">upper_bound</span>(first, last, value, comp));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// greater or equal to</span></span><br><span class="line"><span class="function">ForwardIt <span class="title">lower_bound</span><span class="params">(ForwardIt first, ForwardIt last, <span class="keyword">const</span> T&amp; value, Compare comp)</span></span></span><br><span class="line"><span class="function"><span class="comment">// greater than</span></span></span><br><span class="line"><span class="function">ForwardIt <span class="title">upper_bound</span><span class="params">(ForwardIt first, ForwardIt last, <span class="keyword">const</span> T&amp; value, Compare comp)</span></span></span><br><span class="line"><span class="function"><span class="comment">// equal</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">binary_search</span><span class="params">(ForwardIt first, ForwardIt last, <span class="keyword">const</span> T&amp; value)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="实现">实现</h3>
<h4 id="equal_range">equal_range</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> pair = std::<span class="built_in">equal_range</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), target);</span><br><span class="line">    <span class="keyword">if</span> (pair.first == nums.<span class="built_in">end</span>() || *pair.first != target) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="built_in"><span class="keyword">int</span></span>(pair.first - nums.<span class="built_in">begin</span>()), <span class="built_in"><span class="keyword">int</span></span>(pair.second-nums.<span class="built_in">begin</span>()<span class="number">-1</span>) &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="bound函数">bound函数</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> l = std::<span class="built_in">lower_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), target);</span><br><span class="line">    <span class="keyword">if</span> (l == nums.<span class="built_in">end</span>() || *l!=target) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> r = std::<span class="built_in">upper_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), target);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="built_in"><span class="keyword">int</span></span>(l - nums.<span class="built_in">begin</span>()), <span class="built_in"><span class="keyword">int</span></span>(r-nums.<span class="built_in">begin</span>()<span class="number">-1</span>) &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 28. 找出字符串中第一个匹配项的下标</title>
    <url>/posts/find-the-index-of-the-first-occurrence-in-a-string/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">28. 找出字符串中第一个匹配项的下标</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。 <span id="more"></span></p>
<h3 id="题解">题解</h3>
<p>一、深度优先搜索 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(std::string&amp; haystack, <span class="keyword">int</span> i, std::string&amp; needle, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= needle.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= haystack.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (haystack[i] != needle[j]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(haystack, i+<span class="number">1</span>, needle, j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;haystack.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(haystack, i, needle, <span class="number">0</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 二、顺序匹配 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i+needle.<span class="built_in">size</span>()&lt;=haystack.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j&lt;needle.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i+j] != needle[j]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j == needle.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>dfs</tag>
        <tag>KMP</tag>
        <tag>字符串查找</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 278. 第一个错误的版本</title>
    <url>/posts/first-bad-version/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode.cn/problems/first-bad-version/">278. 第一个错误的版本</a>  难度: <span style="color: rgba(90, 183, 38, 1);">简单</span></p>
<p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。 <span id="more"></span></p>
<p>假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。</p>
<p>你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p>
<h3 id="题解">题解</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The API isBadVersion is defined for you.</span></span><br><span class="line"><span class="comment">// bool isBadVersion(int version);</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r = n;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isBadVersion</span>(m)) &#123;</span><br><span class="line">                r = m; <span class="comment">// 防止跳过正确答案</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 438. 找到字符串中所有字母异位词</title>
    <url>/posts/find-all-anagrams-in-a-string/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">LeetCode 438. 找到字符串中所有字母异位词</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 <code>异位词</code> 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。 <span id="more"></span> <code>异位词</code> 指由相同字母重排列形成的字符串（包括相同的字符串）。</p>
<h3 id="思路">思路</h3>
<ul>
<li>将目标词和候选词按字母顺序排序，和目标词相等的候选词即是异位词</li>
<li>如字符串仅由26个小写字母组成，构建 int[26] hash；若目标词和候选词互为异位词，两者包含的各字符计数值相同。</li>
</ul>
<p>在实现时注意使用滑动窗口思想：下一个候选词相当于当前候选词，删除第一个字符，后面追加一个字符，只用修改两个统计值，而不是全部重新统计。</p>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(std::string s, std::string p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt; p.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 异位词查找：1.将目标词和候选词按字母顺序排序，和目标词相等的候选词即是异位词；2.如字符串仅由26个小写字母组成，构建 int[26] hash；若目标词和候选词互为异位词，两者包含的各字符计数值相同。</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">count_p</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">count_s</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> len = p.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i) &#123;</span><br><span class="line">        ++count_p[p[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        ++count_s[s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count_p == count_s) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        --count_s[s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        ++i;</span><br><span class="line">        <span class="keyword">if</span> (i+len&lt;=s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            ++count_s[s[i+len<span class="number">-1</span>]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>括号生成</title>
    <url>/posts/generate-parentheses/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/generate-parentheses/">22. 括号生成</a> 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。<br />
有效括号组合需满足：左括号必须以正确的顺序闭合。</p>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> n, std::string str, std::vector&lt;std::string&gt;&amp; ret)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == n &amp;&amp; r == n) &#123;</span><br><span class="line">        ret.<span class="built_in">push_back</span>(str);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r &lt; l) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l&lt;n) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(l+<span class="number">1</span>, r, n, str+<span class="string">&quot;(&quot;</span>, ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r&lt;n) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(l, r+<span class="number">1</span>, n, str+<span class="string">&quot;)&quot;</span>, ret);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(l+<span class="number">1</span>, r, n, str+<span class="string">&quot;(&quot;</span>, ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;std::string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::string&gt; ret;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, n, <span class="string">&quot;&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> v = <span class="built_in">generateParenthesis</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> _: v) &#123;</span><br><span class="line">        std::cout &lt;&lt; _ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>dfs</tag>
        <tag>深度优先</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 478. 在圆内随机生成点</title>
    <url>/posts/generate-random-point-in-a-circle/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode.cn/problems/generate-random-point-in-a-circle/">478. 在圆内随机生成点</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给定圆的半径和圆心的位置，实现函数 randPoint ，在圆中产生均匀随机点。 <span id="more"></span></p>
<p>实现 Solution 类:</p>
<p>Solution(double radius, double x_center, double y_center) 用圆的半径 radius 和圆心的位置 (x_center, y_center) 初始化对象 randPoint() 返回圆内的一个随机点。圆周上的一点被认为在圆内。答案作为数组返回 [x, y] 。</p>
<h3 id="题解">题解</h3>
<p>解法一、拒绝采样 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Solution</span>(<span class="keyword">double</span> radius, <span class="keyword">double</span> x_center, <span class="keyword">double</span> y_center) &#123;</span><br><span class="line">        _radius = radius;</span><br><span class="line">        _x_center = x_center;</span><br><span class="line">        _y_center = y_center;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">double</span>&gt; <span class="title">randPoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::random_device rd;</span><br><span class="line">        <span class="function">std::default_random_engine <span class="title">e</span><span class="params">(rd())</span></span>;</span><br><span class="line">        <span class="function">std::uniform_real_distribution&lt;<span class="keyword">double</span>&gt; <span class="title">u</span><span class="params">(-_radius, _radius)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">double</span> x = _x_center + <span class="built_in">u</span>(e);</span><br><span class="line">            <span class="keyword">double</span> y = _y_center + <span class="built_in">u</span>(e);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (std::<span class="built_in">pow</span>(x-_x_center, <span class="number">2</span>) + std::<span class="built_in">pow</span>(y-_y_center, <span class="number">2</span>) &lt; std::<span class="built_in">pow</span>(_radius, <span class="number">2</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;x, y&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> _radius;</span><br><span class="line">    <span class="keyword">double</span> _x_center;</span><br><span class="line">    <span class="keyword">double</span> _y_center;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution* obj = new Solution(radius, x_center, y_center);</span></span><br><span class="line"><span class="comment"> * vector&lt;double&gt; param_1 = obj-&gt;randPoint();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
<p>解法二、极坐标 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Solution</span>(<span class="keyword">double</span> radius, <span class="keyword">double</span> x_center, <span class="keyword">double</span> y_center) &#123;</span><br><span class="line">        _radius = radius;</span><br><span class="line">        _x_center = x_center;</span><br><span class="line">        _y_center = y_center;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        std::random_device rd;</span><br><span class="line">        e = std::<span class="built_in">default_random_engine</span>(<span class="built_in">rd</span>());</span><br><span class="line">        u_r = std::uniform_real_distribution&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, _radius * _radius); <span class="comment">// 保证距离和面积比例一致</span></span><br><span class="line">        u_theta = std::uniform_real_distribution&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">2</span> * M_PI);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">double</span>&gt; <span class="title">randPoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 极坐标</span></span><br><span class="line">        <span class="comment">// 半径 [0, radius]</span></span><br><span class="line">        <span class="comment">// 角度 [0, 2π]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> r = <span class="built_in">sqrt</span>(<span class="built_in">u_r</span>(e));</span><br><span class="line">        <span class="keyword">double</span> theta = <span class="built_in">u_theta</span>(e);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> x = r * <span class="built_in">cos</span>(theta);</span><br><span class="line">        <span class="keyword">double</span> y = r * <span class="built_in">sin</span>(theta);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;_x_center + x, _y_center + y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> _radius;</span><br><span class="line">    <span class="keyword">double</span> _x_center;</span><br><span class="line">    <span class="keyword">double</span> _y_center;</span><br><span class="line"></span><br><span class="line">    std::default_random_engine e;</span><br><span class="line">    std::uniform_real_distribution&lt;<span class="keyword">double</span>&gt; u_r;</span><br><span class="line">    std::uniform_real_distribution&lt;<span class="keyword">double</span>&gt; u_theta;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution* obj = new Solution(radius, x_center, y_center);</span></span><br><span class="line"><span class="comment"> * vector&lt;double&gt; param_1 = obj-&gt;randPoint();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>拒绝采样</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 520. 检测大写字母</title>
    <url>/posts/detect-capital/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/detect-capital/">520. 检测大写字母</a>  难度: <span style="color: rgba(90, 183, 38, 1);">简单</span></p>
<p>我们定义，在以下情况时，单词的大写用法是正确的： <span id="more"></span></p>
<p>全部字母都是大写，比如 "USA" 。 单词中所有字母都不是大写，比如 "leetcode" 。 如果单词不只含有一个字母，只有首字母大写， 比如 "Google" 。 给你一个字符串 word 。如果大写用法正确，返回 true ；否则，返回 false 。</p>
<h3 id="解法">解法</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">detectCapitalUse</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> up_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> lo_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;word.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = word[i];</span><br><span class="line">        <span class="keyword">if</span> (c &lt; <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">            ++up_len;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ++lo_len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;up_len: &quot; &lt;&lt; up_len &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;lo_len: &quot; &lt;&lt; lo_len &lt;&lt; std::endl;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> up_len == word.<span class="built_in">size</span>() || lo_len == word.<span class="built_in">size</span>() || (up_len == <span class="number">1</span> &amp;&amp; word[<span class="number">0</span>] &lt; <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>堆</title>
    <url>/posts/heap/</url>
    <content><![CDATA[<p>对一个完全二叉树来说，所有父节点值都大于（小于）其左右子节点值，就是大堆（小堆）</p>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * before</span></span><br><span class="line"><span class="comment"> *          1</span></span><br><span class="line"><span class="comment"> *      /      \</span></span><br><span class="line"><span class="comment"> *     3        5</span></span><br><span class="line"><span class="comment"> *  /    \     /  \</span></span><br><span class="line"><span class="comment"> *  4      6   13  10</span></span><br><span class="line"><span class="comment"> * / \    / \</span></span><br><span class="line"><span class="comment"> *    8  15 17</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * after</span></span><br><span class="line"><span class="comment"> *         17</span></span><br><span class="line"><span class="comment"> *      /      \</span></span><br><span class="line"><span class="comment"> *     15       13</span></span><br><span class="line"><span class="comment"> *  /    \     /  \</span></span><br><span class="line"><span class="comment"> *  4      9   5  10</span></span><br><span class="line"><span class="comment"> * / \    / \</span></span><br><span class="line"><span class="comment"> *    3  6   8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjustNode</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = cur * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> r = cur * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> latest = cur;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; len &amp;&amp; arr[l] &gt; arr[latest]) &#123;</span><br><span class="line">        latest = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; len &amp;&amp; arr[r] &gt; arr[latest]) &#123;</span><br><span class="line">        latest = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (latest != cur) &#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(arr[latest], arr[cur]);</span><br><span class="line">        <span class="built_in">adjustNode</span>(arr, len, latest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> cur=len / <span class="number">2</span> - <span class="number">1</span>; cur&gt;=<span class="number">0</span>; --cur) &#123;</span><br><span class="line">        <span class="built_in">adjustNode</span>(arr, len, cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">buildHeap</span>(arr, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=len<span class="number">-1</span>; i&gt;<span class="number">0</span>; --i) &#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(arr[i], arr[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">adjustNode</span>(arr, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">13</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">15</span>,<span class="number">17</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> _: arr) &#123;</span><br><span class="line">        std::cout &lt;&lt; _  &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//buildHeap(a, 11);</span></span><br><span class="line">    <span class="built_in">HeapSort</span>(arr, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> _: arr) &#123;</span><br><span class="line">        std::cout &lt;&lt; _  &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>排序算法</tag>
        <tag>堆排序</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 49. 字母异位词分组</title>
    <url>/posts/group-anagrams/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/group-anagrams/">49. 字母异位词分组</a> <code>中等</code></p>
<p>给你一个字符串数组，请你将 <code>字母异位词</code> 组合在一起。可以按任意顺序返回结果列表。 <span id="more"></span></p>
<p><code>字母异位词</code> 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母都恰好只用一次。</p>
<h3 id="思路">思路</h3>
<p>字母异位词在排序后对应相同的词，利用这个性质将排序后的词作为<code>key</code>构建字典，字典<code>value</code>是异位词的列表</p>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">    std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt; dict;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; str: strs) &#123;</span><br><span class="line">        <span class="keyword">auto</span> key = str;</span><br><span class="line">        std::<span class="built_in">sort</span>(key.<span class="built_in">begin</span>(), key.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> it = dict.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it == dict.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            dict.<span class="built_in">insert</span>(&#123;key, &#123;str&#125;&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            it-&gt;second.<span class="built_in">push_back</span>(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::vector&lt;std::string&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; kv: dict) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(kv.second);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>字典</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 114. 二叉树展开为链表</title>
    <url>/posts/flatten-binary-tree-to-linked-list/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表： <span id="more"></span></p>
<p>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。 展开后的单链表应该与二叉树 <code>先序遍历</code> 顺序相同。</p>
<h3 id="思路">思路</h3>
<p>前序遍历即可。其中，需要注意的点：左子树叶子节点的后驱是栈顶元素。</p>
<ul>
<li>时间复杂度：<span class="math inline">\(O(n)\)</span></li>
<li>空间复杂度：<span class="math inline">\(O(n)\)</span></li>
</ul>
<p><strong>官方空间复杂度 <span class="math inline">\(O(1)\)</span> 的解法：</strong></p>
<blockquote>
<p>寻找前驱节点：如果，root不存在左子树，这个子树不需要展开；否则：root右节点的前驱是root的左子树最右的节点，把右子树挂在该前驱下，对该节点进行展开，并继续处理其right节点。</p>
</blockquote>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    std::stack&lt;TreeNode*&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        s.<span class="built_in">push</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        root = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (root) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(root-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">                root-&gt;right = root-&gt;left;</span><br><span class="line">                root-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 后驱是栈顶元素</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    root-&gt;right = s.<span class="built_in">top</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                root = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>链表</tag>
        <tag>前序遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 470. 用 Rand7() 实现 Rand10()</title>
    <url>/posts/implement-rand10-using-rand7/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode.cn/problems/implement-rand10-using-rand7/">470. 用 Rand7() 实现 Rand10()</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给定方法 rand7 可生成 [1,7] 范围内的均匀随机整数，试写一个方法 rand10 生成 [1,10] 范围内的均匀随机整数。</p>
<p>你只能调用 rand7() 且不能调用其他方法。请不要使用系统的 Math.random() 方法。</p>
<p>每个测试用例将有一个内部参数 n，即你实现的函数 rand10() 在测试时将被调用的次数。请注意，这不是传递给 rand10() 的参数。 <span id="more"></span></p>
<h3 id="题解">题解</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        a = (<span class="built_in">rand7</span>() - <span class="number">1</span>) * <span class="number">7</span>; <span class="comment">// [0 - 6] * 7</span></span><br><span class="line">        b = <span class="built_in">rand7</span>();           <span class="comment">// [1 - 7]</span></span><br><span class="line">        r = a + b;             <span class="comment">// [1 - 49] // 每个组合唯一，概率相等</span></span><br><span class="line">        <span class="keyword">if</span> (r &lt;= <span class="number">40</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> r % <span class="number">10</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        a = (<span class="built_in">rand7</span>() - <span class="number">1</span>) * <span class="number">9</span>;</span><br><span class="line">        b = r - <span class="number">40</span>;</span><br><span class="line">        r = a + b;</span><br><span class="line">        <span class="keyword">if</span> (r &lt;= <span class="number">60</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> r % <span class="number">10</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        a = (r -  <span class="number">60</span> - <span class="number">1</span>) * <span class="number">7</span>;</span><br><span class="line">        b = <span class="built_in">rand7</span>();</span><br><span class="line">        r = a + b;</span><br><span class="line">        <span class="keyword">if</span> (r &lt;= <span class="number">20</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> r % <span class="number">10</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>拒绝采样</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 208. 实现 Trie (前缀树)</title>
    <url>/posts/implement-trie-prefix-tree/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p><code>Trie</code>（发音类似 "try"）或者说 <em><code>前缀树</code></em> 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。 <span id="more"></span></p>
<p>请你实现 Trie 类：</p>
<ul>
<li><code>Trie()</code> 初始化前缀树对象。</li>
<li><code>void insert(String word)</code> 向前缀树中插入字符串 <code>word</code> 。</li>
<li><code>boolean search(String word)</code> 如果字符串 <code>word</code> 在前缀树中，返回 <code>true</code>（即，在检索之前已经插入）；否则，返回 <code>false</code> 。</li>
<li><code>boolean startsWith(String prefix)</code> 如果之前已经插入的字符串 <code>word</code> 的前缀之一为 <code>prefix</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>
</ul>
<h3 id="题解">题解</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Trie* next[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">bool</span> is_word = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c: word) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!node-&gt;next[c-<span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">                node-&gt;next[c-<span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node = node-&gt;next[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;is_word = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c: word) &#123;</span><br><span class="line">            node = node-&gt;next[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node-&gt;is_word;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c: prefix) &#123;</span><br><span class="line">            node = node-&gt;next[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie* obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj-&gt;insert(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>字典树</tag>
        <tag>前缀树</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 343.整数拆分</title>
    <url>/posts/integer-break/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/integer-break/">343.整数拆分</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给定一个正整数<code>n</code>，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。 <span id="more"></span></p>
<h3 id="思路">思路</h3>
<p>动态规划 <span class="math display">\[
\begin{equation}
    F(i)=\max\limits_{1\leq j\leq i/2} \{\max(j, dp[j])*max(i-j, dp[i-j])\}
\end{equation}
\]</span> 时间复杂度：<span class="math inline">\(O(n^2)\)</span>，空间复杂度：<span class="math inline">\(O(n)\)</span></p>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=i/<span class="number">2</span>; ++j) &#123;</span><br><span class="line">            dp[i] = std::<span class="built_in">max</span>(dp[i], std::<span class="built_in">max</span>(j, dp[j]) * std::<span class="built_in">max</span>(i-j, dp[i-j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数学方法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> quotient = n / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> remainder = n % <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (remainder == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)<span class="built_in">pow</span>(<span class="number">3</span>, quotient);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (remainder == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">return</span></span> (<span class="keyword">int</span>)<span class="built_in">pow</span>(<span class="number">3</span>, quotient - <span class="number">1</span>) * <span class="number">4</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">return</span></span> (<span class="keyword">int</span>)<span class="built_in">pow</span>(<span class="number">3</span>, quotient) * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 334. 递增的三元子序列</title>
    <url>/posts/increasing-triplet-subsequence/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/increasing-triplet-subsequence/">334. 递增的三元子序列</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。 <span id="more"></span></p>
<p>如果存在这样的三元组下标 (i, j, k) 且满足 i &lt; j &lt; k ，使得 nums[i] &lt; nums[j] &lt; nums[k] ，返回 true ；否则，返回 false 。</p>
<h3 id="题解">题解</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">increasingTriplet</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vec.<span class="built_in">size</span>() &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = std::numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">    <span class="keyword">int</span> j = std::numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k: vec) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; k &amp;&amp; j &lt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k &lt; i) &#123;</span><br><span class="line">            i = k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 贪心 j要尽可能小，才能保证符合条件的k&gt;j</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; k &amp;&amp; k &lt; j) &#123;</span><br><span class="line">            j = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">increasingTriplet</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vec.<span class="built_in">size</span>() &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = std::numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">    <span class="keyword">int</span> j = std::numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k: vec) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; j) &#123; <span class="comment">// 隐藏条件：已经存在一个i使得i&lt;j</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k &gt; i) &#123; <span class="comment">// 隐藏条件：k小于之前的j，否则走不到这里</span></span><br><span class="line">            j = k;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 226. 反转二叉树</title>
    <url>/posts/invert-binary-tree/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树</a>  难度: <span style="color: rgba(90, 183, 38, 1);">简单</span></p>
<p>翻转一棵二叉树。 <span id="more"></span></p>
<h3 id="思路">思路</h3>
<p>前序遍历，对于每个节点交换左右子树，递归处理左、右子树。</p>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">swap</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>深度优先</tag>
        <tag>前序遍历</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 160. 相交链表</title>
    <url>/posts/intersection-of-two-linked-lists/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a>  难度: <span style="color: rgba(90, 183, 38, 1);">简单</span></p>
<p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 <code>null</code> 。 <span id="more"></span></p>
<p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong>。</p>
<h3 id="思路">思路</h3>
<p>两个单链表相交形状为 <code>Y</code> 。假设其中一条链表 <code>A</code> 长度为<span class="math inline">\(l_1\)</span>，另一条链表 <code>B</code> 长度为<span class="math inline">\(l_2\)</span>，<span class="math inline">\(l_1 &gt;= l_2\)</span>，若 <code>A</code> 先走<span class="math inline">\(l_1-l_2\)</span>步，<code>B</code> 再和 <code>A</code> 一起走，两者第一次指向相同节点：不为 <code>null</code> 必然在交点，为 <code>null</code> 则说明两者不相交。其中，通过分别遍历一遍获取两个链表的长度。</p>
<p>以上逻辑需要的几个步骤：</p>
<ul>
<li>分别遍历</li>
<li>判断长短链表</li>
<li>长链表先走</li>
<li>同时走直到相等</li>
</ul>
<h4 id="一种简捷的思路">一种简捷的思路</h4>
<p><span class="math inline">\(l_1+l_2 == l_2+l_1\)</span>，两个指针分别走 <span class="math inline">\(l_1\)</span>、<span class="math inline">\(l_2\)</span> 和 <span class="math inline">\(l_2\)</span>、<span class="math inline">\(l_1\)</span>，如果两者相交：第一次指向相同节点必然在交点处。</p>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">    ListNode* p1 = headA;</span><br><span class="line">    ListNode* p2 = headB;</span><br><span class="line">    <span class="keyword">while</span> (p1 != p2) &#123;</span><br><span class="line">        p1 = p1 ? p1-&gt;next : headB;</span><br><span class="line">        p2 = p2 ? p2-&gt;next : headA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 374. 猜数字大小</title>
    <url>/posts/guess-number-higher-or-lower/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode.cn/problems/guess-number-higher-or-lower/">374. 猜数字大小</a>  难度: <span style="color: rgba(90, 183, 38, 1);">简单</span></p>
<p>猜数字游戏的规则如下：</p>
<p>每轮游戏，我都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。 如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。 你可以通过调用一个预先定义好的接口 int guess(int num) 来获取猜测结果，返回值一共有 3 种可能的情况（-1，1 或 0）： <span id="more"></span></p>
<p>-1：我选出的数字比你猜的数字小 pick &lt; num 1：我选出的数字比你猜的数字大 pick &gt; num 0：我选出的数字和你猜的数字一样。恭喜！你猜对了！pick == num 返回我选出的数字。</p>
<h3 id="题解">题解</h3>
<p>看到了16年的<a href="https://leetcode.cn/submissions/detail/181487193/">提交记录</a>，当时用java写的，真的蹩脚</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">guessNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> r = n;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> g = <span class="built_in">guess</span>(m);</span><br><span class="line">        <span class="keyword">if</span> (g == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (g &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = m - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二分搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 55. 跳跃游戏</title>
    <url>/posts/jump-game/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/jump-game/">55. 跳跃游戏</a> <code>中等</code></p>
<p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。 <span id="more"></span></p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个下标。</p>
<h3 id="思路">思路</h3>
<p>从左往右扫描，在每处选择当前最优解</p>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> stand = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="comment">// 出现最优解已经到达不了的下标，也就无法达到最后了</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; stand + nums[stand]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 贪心，不断选择当前能走更远的下标</span></span><br><span class="line">        <span class="keyword">if</span>(i + nums[i] &gt; stand + nums[stand]) &#123;</span><br><span class="line">            stand = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 141. 环形链表</title>
    <url>/posts/linked-list-cycle/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a> 给定一个链表，判断链表中是否有环。 <span id="more"></span></p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p>
<h3 id="思路">思路</h3>
<p>快慢指针，快指针一次跳过2个节点，慢指针一次跳过1个节点。</p>
<ul>
<li>如果不存在环，则快指针先到达nullptr节点与慢指针不相等。</li>
<li>如果存在环，则快慢指针会在环上相遇，指向相同的节点。</li>
</ul>
<p>由于存在环，两者都会走到环上。假设两者第一次同时在环上，快指针距离慢指针的节点数为n，那么2n步后两者一定相遇</p>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || !head-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode* fast = head;</span><br><span class="line">    ListNode* slow = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next &amp;&amp; fast!=slow);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fast == slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>快慢指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1143. 最长公共子序列</title>
    <url>/posts/longest-common-subsequence/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143. 最长公共子序列</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <code>公共子序列</code> 的长度。如果不存在 <code>公共子序列</code> ，返回 <code>0</code> 。 <span id="more"></span></p>
<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<p>例如，<code>"ace"</code> 是 <code>"abcde"</code> 的子序列，但 <code>"aec"</code> 不是 <code>"abcde"</code> 的子序列。 两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p>
<h3 id="思路">思路</h3>
<p>动态规划 <span class="math display">\[\begin{equation}
    F_{a,b}(i,j)=\begin{cases}
    0 &amp;  \text{if }min(i,j) = 0, \\
    \\
    max\begin{cases}
    F_{a,b}(i-1,j) \\
    F_{a,b}(i,j-1) \\
    F_{a,b}(i-1,j-1) + 1_{a_i == b_j} 
    \end{cases}
    &amp;  \text{otherwise}.
    \end{cases}
\end{equation}\]</span></p>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = text1.<span class="built_in">length</span>() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> len2 = text2.<span class="built_in">length</span>() + <span class="number">1</span>;</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(len1, std::vector&lt;<span class="keyword">int</span>&gt;(len2, <span class="number">0</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len1; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;len2; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            dp[i][j] = std::<span class="built_in">max</span>(&#123;dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+len&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[len1<span class="number">-1</span>][len2<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 397. 整数替换</title>
    <url>/posts/integer-replacement/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/integer-replacement/">397. 整数替换</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给定一个正整数 <code>n</code> ，你可以做如下操作：</p>
<p>如果 <code>n</code> 是偶数，则用 n / 2替换 <code>n</code> 。 如果 <code>n</code> 是奇数，则可以用 n + 1或n - 1替换 <code>n</code> 。 <code>n</code> 变为 <code>1</code> 所需的最小替换次数是多少？</p>
<span id="more"></span>
<h3 id="思路">思路</h3>
<p>由于昨天刚写了一道动态规划的题目<a href="https://leetcode-cn.com/problems/coin-change/">322. 零钱兑换</a>，从1到n自底向上，自然就求出解了。其中，由于n与n+1有关，将n+1转换成(n+1)/2+2就可以了。提交结果：<strong>超出时间限制</strong>，Badcase是200000000</p>
<p>如果我们按上面的思路需要200000000次，但直觉告诉我们，直接除以2，一半时间都省了。那方案就是自顶向下，每次到偶数都会降低一半的问题空间，时间复杂度O(logn)</p>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">integerReplacement</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">integerReplacement</span>(n / <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">min</span>(<span class="built_in">integerReplacement</span>(n - <span class="number">1</span>) + <span class="number">1</span>, <span class="built_in">integerReplacement</span>(n / <span class="number">2</span> + <span class="number">1</span>) + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 128. 最长连续序列</title>
    <url>/posts/longest-consecutive-sequence/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">128. 最长连续序列</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。 <span id="more"></span></p>
<p>请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</p>
<h3 id="思路">思路</h3>
<p>暴力：遍历nums，对于每一个数x：判断x+1、x+2...是否存在（提前构建hash），直到x+n不存在，那序列长度是n，时间复杂度是O(n^2)。</p>
<p>优化：1.将vector插入一个set去重。2.对于一个存在x-1的元素是没有必要遍历的，降低时间复杂度。每个元素最多遍历2次，时间复杂度O(n)。</p>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unordered_set&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(nums.begin(), nums.end())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x: s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">count</span>(x<span class="number">-1</span>)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (s.<span class="built_in">count</span>(++x)) &#123;</span><br><span class="line">            ++len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        longest = std::<span class="built_in">max</span>(longest, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> longest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 674. 最长连续递增序列</title>
    <url>/posts/longest-continuous-increasing-subsequence/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/">LeetCode 674. 最长连续递增序列</a>  难度: <span style="color: rgba(90, 183, 38, 1);">简单</span></p>
<p>给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。 <span id="more"></span></p>
<p>连续递增的子序列 可以由两个下标 <code>l</code> 和 <code>r</code>（<code>l &lt; r</code>）确定，如果对于每个 <code>l &lt;= i &lt; r</code>，都有 <code>nums[i] &lt; nums[i + 1]</code> ，那么子序列 <code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code> 就是连续递增子序列。</p>
<h3 id="思路">思路</h3>
<p>todo</p>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i<span class="number">-1</span>] &lt; nums[i]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        len = std::<span class="built_in">max</span>(len, i - cur);</span><br><span class="line">        cur = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for循环未更新过len的情况</span></span><br><span class="line">    len = std::<span class="built_in">max</span>(len, <span class="built_in"><span class="keyword">int</span></span>(nums.<span class="built_in">size</span>()) - cur);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 142. 环形链表II</title>
    <url>/posts/linked-list-cycle-ii/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表II</a> 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 <span id="more"></span></p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p>
<p>说明：不允许修改给定的链表。</p>
<h3 id="思路">思路</h3>
<p>判断是否有环，解法见<a href="/posts/linked-list-cycle/">141. 环形链表</a> 这里讨论如果存在环如何找到入环处？将带环链表抽象为如下几何形状 <img data-src="https://z3.ax1x.com/2021/10/10/5E5O7d.png" /> <em>假设</em> 两个指针在环上<span class="math inline">\(P\)</span>点相遇，在相遇时 慢指针在环上走了<span class="math inline">\(m\)</span>圈，快指针在环上走了<span class="math inline">\(n\)</span>圈（<span class="math inline">\(m\)</span>和<span class="math inline">\(n\)</span>都为自然数。且<span class="math inline">\(m=0||m=1\)</span>，<span class="math inline">\(n{\geq}m\)</span>）：<br />
链表直线长度记作: <span class="math inline">\(x\)</span><br />
链表环形周长记作: <span class="math inline">\(c\)</span><br />
弧<span class="math inline">\(AP\)</span>长度记作: <span class="math inline">\(y\)</span></p>
<p>存在:<br />
<span class="math display">\[\begin{equation}
\begin{aligned}
2*(x + m*c + y) &amp;= x + n*c + y \\
x &amp;= (n-m)*c -y \\
\end{aligned}
\end{equation}\]</span></p>
<p>所以，此时快指针移动到起点，慢指针从<span class="math inline">\(P\)</span>点，两者步长都为1，再次相遇时在<span class="math inline">\(A\)</span></p>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || !head-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode* fast = head;</span><br><span class="line">    ListNode* slow = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next &amp;&amp; fast!=slow);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fast != slow) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找入环处</span></span><br><span class="line">    fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>快慢指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 14. 最长公共前缀</title>
    <url>/posts/longest-common-prefix/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/longest-common-prefix/">14. 最长公共前缀</a>  难度: <span style="color: rgba(90, 183, 38, 1);">简单</span></p>
<p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 <code>""</code>。</p>
<span id="more"></span>
<h3 id="思路">思路</h3>
<p>todo</p>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> len = std::numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; str: strs) &#123;</span><br><span class="line">        len = std::<span class="built_in">min</span>(len, str.<span class="built_in">length</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;strs.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strs[<span class="number">0</span>][i] != strs[j][i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> strs[<span class="number">0</span>].<span class="built_in">substr</span>(<span class="number">0</span>, i);;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> strs[<span class="number">0</span>].<span class="built_in">substr</span>(<span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树的最近公共祖先</title>
    <url>/posts/lowest-common-ancetor-of-a-binary-tree/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a> 给定一棵二叉树，找到该树中给定两个节点的最近公共祖先</p>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root == p || root == q) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode* left = <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* right = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">            left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">            right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &amp;&amp; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 300. 最长递增子序列</title>
    <url>/posts/longest-increasing-subsequence/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。 <span id="more"></span></p>
<h3 id="题解">题解</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(len, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i) &#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                dp[i] = std::<span class="built_in">max</span>(dp[j] + <span class="number">1</span>, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans = std::<span class="built_in">max</span>(ans, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>子序列</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 827. 最大人工岛</title>
    <url>/posts/making-a-large-island/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode.cn/problems/making-a-large-island/">827. 最大人工岛</a> 难度: <span style="color: rgba(239, 71, 67, 1);">困难</span></p>
<p>给你一个大小为 <code>n x n</code> 二进制矩阵 <code>grid</code> 。<em>最多</em> 只能将一格 <code>0</code> 变成 <code>1</code> 。</p>
<p>返回执行此操作后，<code>grid</code> 中最大的岛屿面积是多少？ <span id="more"></span></p>
<p>岛屿 由一组上、下、左、右四个方向相连的 <code>1</code> 形成。</p>
<h3 id="题解">题解</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> id, <span class="keyword">int</span>&amp; size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span> || i&gt;=grid.<span class="built_in">size</span>() || j&gt;=grid.<span class="built_in">size</span>() || grid[i][j] != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    grid[i][j] = id;</span><br><span class="line">    ++size;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(grid, i+<span class="number">1</span>, j, id, size);</span><br><span class="line">    <span class="built_in">dfs</span>(grid, i<span class="number">-1</span>, j, id, size);</span><br><span class="line">    <span class="built_in">dfs</span>(grid, i, j<span class="number">-1</span>, id, size);</span><br><span class="line">    <span class="built_in">dfs</span>(grid, i, j+<span class="number">1</span>, id, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">largestIsland</span><span class="params">(std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> island_id = <span class="number">2</span>;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; island2size = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = grid.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(grid, i, j, island_id, size);</span><br><span class="line">            <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                island2size.<span class="built_in">push_back</span>(size);</span><br><span class="line">                ++island_id;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                std::unordered_set&lt;<span class="keyword">int</span>&gt; uniq;</span><br><span class="line">                <span class="keyword">if</span> (i+<span class="number">1</span> &lt; n &amp;&amp; grid[i+<span class="number">1</span>][j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    uniq.<span class="built_in">insert</span>(grid[i+<span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i<span class="number">-1</span>][j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    uniq.<span class="built_in">insert</span>(grid[i<span class="number">-1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; grid[i][j<span class="number">-1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    uniq.<span class="built_in">insert</span>(grid[i][j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j+<span class="number">1</span>&lt;n &amp;&amp; grid[i][j+<span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    uniq.<span class="built_in">insert</span>(grid[i][j+<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> k : uniq) &#123;</span><br><span class="line">                    s += island2size[k];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                m = std::<span class="built_in">max</span>(m, s+<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                m = std::<span class="built_in">max</span>(m, island2size[grid[i][j]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 5. 最长回文子串</title>
    <url>/posts/longest-palindromic-substring/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给你一个字符串 s，找到 s 中最长的回文子串。 <span id="more"></span></p>
<h3 id="题解">题解</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ababa -&gt; a#b#a#b#a</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>()*<span class="number">2</span><span class="number">-1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = i/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> r = i/<span class="number">2</span> + i%<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l&gt;=<span class="number">0</span> &amp;&amp; r&lt;s.<span class="built_in">size</span>() &amp;&amp; s[l] == s[r]) &#123;</span><br><span class="line">            ++x;</span><br><span class="line">            --l;</span><br><span class="line">            ++r;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        x = x*<span class="number">2</span> + i%<span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; len) &#123;</span><br><span class="line">            len = x;</span><br><span class="line">            pos = i/<span class="number">2</span>-(len<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">substr</span>(pos, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LRU</title>
    <url>/posts/lru/</url>
    <content><![CDATA[<p>双端队列实现LRU</p>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DLinkNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    DLinkNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">    DLinkNode* next = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="keyword">int</span> capacity) : <span class="built_in">capacity_</span>(capacity), <span class="built_in">size_</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// dummy</span></span><br><span class="line">        head_ = <span class="keyword">new</span> <span class="built_in">DLinkNode</span>();</span><br><span class="line">        tail_ = <span class="keyword">new</span> <span class="built_in">DLinkNode</span>();</span><br><span class="line">        head_-&gt;next = tail_;</span><br><span class="line">        tail_-&gt;pre = head_;</span><br><span class="line">        head_-&gt;val= <span class="number">-99</span>;</span><br><span class="line">        tail_-&gt;val = <span class="number">-99</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">LRUCache</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> head_;</span><br><span class="line">        <span class="keyword">delete</span> tail_;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = hash_table_.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it == hash_table_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DLinkNode* p = it-&gt;second;</span><br><span class="line">        <span class="comment">// remove</span></span><br><span class="line">        p-&gt;pre-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next-&gt;pre = p-&gt;pre;</span><br><span class="line">        <span class="comment">// insert</span></span><br><span class="line">        p-&gt;next = head_-&gt;next;</span><br><span class="line">        head_-&gt;next = p;</span><br><span class="line">        p-&gt;next-&gt;pre = p;</span><br><span class="line">        p-&gt;pre = head_;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> p-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = hash_table_.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it == hash_table_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="comment">//std::cout &lt;&lt; &quot;not find: &quot; &lt;&lt; key &lt;&lt; std::endl;</span></span><br><span class="line">            DLinkNode* p = <span class="keyword">new</span> <span class="built_in">DLinkNode</span>();</span><br><span class="line">            p-&gt;val = value;</span><br><span class="line">            p-&gt;key = key;</span><br><span class="line"></span><br><span class="line">            p-&gt;next = head_-&gt;next;</span><br><span class="line">            head_-&gt;next = p;</span><br><span class="line">            p-&gt;next-&gt;pre = p;</span><br><span class="line">            p-&gt;pre = head_;</span><br><span class="line"></span><br><span class="line">            hash_table_.<span class="built_in">insert</span>(&#123;key, p&#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (++size_ &gt; capacity_) &#123;</span><br><span class="line">                <span class="comment">// remove</span></span><br><span class="line">                 p = tail_-&gt;pre;</span><br><span class="line">                 p-&gt;pre-&gt;next = tail_;</span><br><span class="line">                 tail_-&gt;pre = p-&gt;pre;</span><br><span class="line">                 hash_table_.<span class="built_in">erase</span>(p-&gt;key);</span><br><span class="line">                 <span class="comment">//std::cout &lt;&lt; &quot;rm element&quot; &lt;&lt; p-&gt;key &lt;&lt; std::endl;</span></span><br><span class="line">                 <span class="keyword">delete</span> p;</span><br><span class="line">                size_ = capacity_;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DLinkNode* p = it-&gt;second;</span><br><span class="line">        <span class="comment">// remove</span></span><br><span class="line">        p-&gt;pre-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next-&gt;pre = p-&gt;pre;</span><br><span class="line">        <span class="comment">// insert</span></span><br><span class="line">        p-&gt;next = head_-&gt;next;</span><br><span class="line">        head_-&gt;next = p;</span><br><span class="line">        p-&gt;next-&gt;pre = p;</span><br><span class="line">        p-&gt;pre = head_;</span><br><span class="line"></span><br><span class="line">        p-&gt;val = value;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    DLinkNode* head_;</span><br><span class="line">    DLinkNode* tail_;</span><br><span class="line">    <span class="keyword">size_t</span> capacity_;</span><br><span class="line">    <span class="keyword">size_t</span> size_;</span><br><span class="line"></span><br><span class="line">    std::unordered_map&lt;<span class="keyword">int</span>, DLinkNode*&gt; hash_table_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[&quot;LRUCache&quot;,&quot;put&quot;,&quot;put&quot;,&quot;get&quot;,&quot;put&quot;,&quot;get&quot;,&quot;put&quot;,&quot;get&quot;,&quot;get&quot;,&quot;get&quot;]</span></span><br><span class="line"><span class="comment">//[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[&quot;LRUCache&quot;,&quot;put&quot;,&quot;put&quot;,&quot;get&quot;,&quot;put&quot;,&quot;put&quot;,&quot;get&quot;]</span></span><br><span class="line"><span class="comment">[[2],[2,1],[2,2],[2],[1,1],[4,1],[2]]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 3. 无重复的最长子串</title>
    <url>/posts/longest-substring-without-repeating-characters/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复的最长子串</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<span id="more"></span>
<h3 id="题解">题解</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(std::string s)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">last_pos</span><span class="params">(<span class="number">128</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cur_len = <span class="number">0</span>; <span class="comment">// 当前窗口（不含重复字符）大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="comment">// 以当前字符为参考对象，分两种情况：</span></span><br><span class="line">        <span class="comment">// 1.未出现过</span></span><br><span class="line">        <span class="keyword">if</span> (last_pos[s[i]] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            last_pos[s[i]] = i;</span><br><span class="line">            ++cur_len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.出现过的</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 且出现在当前窗口中</span></span><br><span class="line">            <span class="keyword">if</span> (i - last_pos[s[i]] &lt;= cur_len) &#123;</span><br><span class="line">                max_len = std::<span class="built_in">max</span>(cur_len, max_len);</span><br><span class="line">                cur_len = i - last_pos[s[i]]; <span class="comment">// 重置窗口</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++cur_len;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            last_pos[s[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">max</span>(cur_len, max_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 20220301重刷</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">last_pos</span><span class="params">(<span class="number">128</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;s.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = last_pos[s[j]];</span><br><span class="line">        <span class="keyword">if</span> (pos &gt;= <span class="number">0</span> &amp;&amp; j - pos &lt;= len) &#123;</span><br><span class="line">            len = j - pos;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ++len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans = std::<span class="built_in">max</span>(ans, len);</span><br><span class="line">        last_pos[s[j]] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 169. 多数元素</title>
    <url>/posts/majority-element/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/majority-element/">169. 多数元素</a>  难度: <span style="color: rgba(90, 183, 38, 1);">简单</span></p>
<p>给定一个大小为 <code>n</code> 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 <code>⌊n/2⌋</code> 的元素。 <span id="more"></span></p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<h3 id="思路">思路</h3>
<p>一些方法：</p>
<ul>
<li>排序，下标⌊n/2⌋就是多数元素 时间复杂度 O(NlogN)</li>
<li>哈希表，统计每个元素出现的次数 时间复杂度 O(N)，需要额外O(N)空间</li>
<li>计数抵消，如果两个数不相等就互相抵消，那么最后剩下的一定是多数元素</li>
</ul>
<p>其中，<code>计数抵消</code> 具体实现通过维护一个计数器 <code>cnt</code>，假设 <code>ans</code> 为要找的多数元素。遍历元素 <code>e</code> 和 <code>ans</code> 不同时 <code>cnt--</code>，否则 <code>cnt++</code>。当 <code>cnt == 0</code> 时说明 <code>ans</code> 已经被抵消完，不可能是多数元素，<code>ans</code> 更新为下一个元素。</p>
<p>第一次实现时：<code>cnt == 0</code>，我将 <code>ans</code> 更新为当前元素（未思考太多）。在写上面的分析逻辑时认为： <code>ans</code> 应该更新为下一个元素才对。但之前的代码是 AC 的，是 bad case 没有覆盖到，还是这种写法也对？</p>
<p>仔细分析后发现：<code>cnt == 0</code> 时的当前元素 <code>e</code> 是否放入后面部分多数元素是没有影响的。</p>
<ol type="1">
<li>假设之前没遇到多数元素，那明显对多数元素无影响。</li>
<li>假设之前遇到过多数元素，若之前遇到的多数元素个数为 <code>n</code>，那也有 <code>n</code> 个非多数元素(且不是 <code>e</code>，<code>e</code>是被非多数元素抵消的)和多数元素抵消，因此剩余的多数元素还是占多数。</li>
</ol>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans= nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != ans) &#123;</span><br><span class="line">            --cnt;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">0</span>) &#123;</span><br><span class="line">            ans = nums[++i];</span><br><span class="line">            cnt = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>计数抵消</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 221. 最大正方形</title>
    <url>/posts/maximal-square/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/maximal-square/">221. 最大正方形</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>在一个由 <code>'0'</code> 和 <code>'1'</code> 组成的二维矩阵内，找到只包含 <code>'1'</code> 的最大正方形，并返回其面积。 <span id="more"></span></p>
<h3 id="思路">思路</h3>
<p>暴力搜索： 遍历每一个元素，将该元素作为一个正方形的左上角，再不断尝试扩大正方形，直到不满足条件，搜索当前最大正方形面积。这样遍历结束就可以挑选全局正方形最大面积。时间复杂度 <code>O(m*n*min(m,n)^2)</code>。</p>
<p>动态规划： 如何才能在后面的遍历中复用前面遍历的结果呢？遍历中可以考察以元素 <code>(i,j)</code> 作为右下角的最大正方形面积，这个面积与 <code>(i-1,j)</code>、<code>(i-1,j-1)</code> 、<code>(i,j-1)</code> 有关。</p>
<ul>
<li>如果，解为 <code>0</code>。</li>
<li>否则，解为 <code>(i-1,j)</code>、<code>(i-1,j-1)</code> 、<code>(i,j-1)</code> 三者解的最小值 + 1。</li>
</ul>
<h3 id="实现">实现</h3>
<h4 id="暴力搜索">暴力搜索</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> w = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> h = matrix.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以 i,j 为正方形左上角，不断在下方和右侧增加一行一列</span></span><br><span class="line">        <span class="keyword">auto</span> search = [&amp;](<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i+x&lt;h &amp;&amp; j+x&lt;w) &#123;</span><br><span class="line">                <span class="comment">// 判断新增行 _|、列是否存在 &#x27;0&#x27;</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;=x; ++k) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (matrix[i+x][j+k] == <span class="string">&#x27;0&#x27;</span> || matrix[i+k][j+x] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> x*x;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                ++x;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> x*x;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matrix.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;matrix[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                ans = std::<span class="built_in">max</span>(ans, <span class="built_in">search</span>(i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="动态规划">动态规划</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(std::vector&lt;std::vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> w = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(h, std::vector&lt;<span class="keyword">int</span>&gt;(w, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;h; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;w; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">0</span> || j==<span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = std::<span class="built_in">min</span>(&#123;dp[i<span class="number">-1</span>][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]&#125;) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ans = std::<span class="built_in">max</span>(ans, dp[i][j]*dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 104. 二叉树的最大深度</title>
    <url>/posts/maximum-depth-of-binary-tree/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a> 给定一个二叉树，找出其最大深度。 <span id="more"></span> 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<h3 id="思路">思路</h3>
<p>两种思路：</p>
<ul>
<li>深度优先，通过递归实现（本文实现）</li>
<li>广度优先，参考<a href="/posts/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></li>
</ul>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left), <span class="built_in">maxDepth</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>深度优先</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 152. 乘积最大子数组</title>
    <url>/posts/maximum-product-subarray/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/rectangle-area/">223. 矩形面积</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。 <span id="more"></span></p>
<h3 id="思路">思路</h3>
<p>由前向后遍历，对于元素 <span class="math inline">\(e\)</span>，在它之前的最大子数组乘积记作 <span class="math inline">\(PMX\)</span>，最小子数组乘积记作 <span class="math inline">\(PMN\)</span>，包含 <span class="math inline">\(e\)</span> 的最大子数组乘积 <span class="math inline">\(y\)</span> 分三种情况讨论：</p>
<ul>
<li><span class="math inline">\(e=0\)</span>，<span class="math inline">\(y=0\)</span></li>
<li><span class="math inline">\(e&gt;0\)</span>，如果 <span class="math inline">\(PMX&gt;0\)</span>，<span class="math inline">\(y=e*PMX\)</span>，否则 <span class="math inline">\(y=e\)</span></li>
<li><span class="math inline">\(e&lt;0\)</span>，如果 <span class="math inline">\(PMN&lt;0\)</span>，<span class="math inline">\(y=e*PMN\)</span>，否则 <span class="math inline">\(y=e\)</span></li>
</ul>
<p>包含 <span class="math inline">\(e\)</span> 的最小子数组乘积 <span class="math inline">\(z\)</span> 计算方式类似：</p>
<ul>
<li><span class="math inline">\(e=0\)</span>，<span class="math inline">\(z=0\)</span></li>
<li><span class="math inline">\(e&gt;0\)</span>，如果 <span class="math inline">\(PMN&lt;0\)</span>，<span class="math inline">\(z=e*PMX\)</span>，否则 <span class="math inline">\(z=e\)</span></li>
<li><span class="math inline">\(e&lt;0\)</span>，如果 <span class="math inline">\(PMN&gt;0\)</span>，<span class="math inline">\(z=e*PMX\)</span>，否则 <span class="math inline">\(z=e\)</span></li>
</ul>
<p><strong>换种思路</strong><br />
我们并不是在遍历过程中只记录最大值和当前元素积作为最大值，最小值和当前元素积也可能作为最大值，我们只需要 记录 <span class="math inline">\(PMN\)</span> 、<span class="math inline">\(PMX\)</span>，每个要素 <span class="math inline">\(e\)</span> 分别和 <span class="math inline">\(PMN\)</span> 、<span class="math inline">\(PMX\)</span> 的乘积，以及 <span class="math inline">\(e\)</span> 三者都有可能是最大值、最小值。 这样逻辑就简单多了。</p>
<h3 id="实现">实现</h3>
<h4 id="自己繁琐方式">自己繁琐方式</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> PMX = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> PMN = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max = std::numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            PMX = <span class="number">0</span>;</span><br><span class="line">            PMN = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (PMX &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                PMX *= nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                PMX = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (PMN &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                PMN *= nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                PMN = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> P_ = PMX;</span><br><span class="line">            <span class="keyword">if</span> (PMN &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                PMX = PMN * nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                PMX = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (P_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                PMN = P_ * nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                PMN = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        max = std::<span class="built_in">max</span>(max, PMX);</span><br><span class="line">        max = std::<span class="built_in">max</span>(max, PMN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="官方简单方式">官方简单方式</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> PMN = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> PMX = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> ans = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = std::<span class="built_in">minmax</span>(&#123;nums[i], PMN * nums[i], PMX * nums[i]&#125;);</span><br><span class="line">        PMN = p.first;</span><br><span class="line">        PMX = p.second;</span><br><span class="line">        ans = std::<span class="built_in">max</span>(ans, PMX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>子数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 56. 合并区间</title>
    <url>/posts/merge-intervals/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/merge-intervals/">56. 合并区间</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。 <span id="more"></span></p>
<h3 id="思路">思路</h3>
<p>首先按区间下界对所有区间排序，时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。再从前往后遍历，对于有重叠的区间选择更大的上界，未重叠说明上一个区间合并结束。</p>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">    <span class="keyword">if</span> (intervals.<span class="built_in">size</span>() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> intervals;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::<span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; cur = intervals[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;intervals.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="comment">// 不和cur相交，cur合并结束</span></span><br><span class="line">        <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &gt; cur[<span class="number">1</span>]) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(cur);</span><br><span class="line">            cur = intervals[i];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重叠则选择更大的上界</span></span><br><span class="line">        <span class="keyword">if</span> (intervals[i][<span class="number">1</span>] &gt; cur[<span class="number">1</span>]) &#123;</span><br><span class="line">            cur[<span class="number">1</span>] = intervals[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环外需要把最后一个区间添加到ans</span></span><br><span class="line">    ans.<span class="built_in">push_back</span>(cur);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1464. 数组中两元素的最大乘积</title>
    <url>/posts/maximum-product-of-two-elements-in-an-array/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode.cn/problems/maximum-product-of-two-elements-in-an-array/">1464. 数组中两元素的最大乘积</a>  难度: <span style="color: rgba(90, 183, 38, 1);">简单</span></p>
<p>给你一个整数数组 nums，请你选择数组的两个不同下标 i 和 j，使 (nums[i]-1)*(nums[j]-1) 取得最大值。</p>
<p>请你计算并返回该式的最大值。 <span id="more"></span></p>
<ul>
<li>2 &lt;= nums.length &lt;= 500</li>
<li>1 &lt;= nums[i] &lt;= 10^3</li>
</ul>
<h3 id="题解">题解</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">        --num;</span><br><span class="line">        <span class="keyword">if</span> (num &gt; i) &#123;</span><br><span class="line">            j = i; <span class="comment">// 需要同时更新第2大</span></span><br><span class="line">            i = num;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; j) &#123;</span><br><span class="line">            j = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i * j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 88. 合并两个有序数组</title>
    <url>/posts/merge-sorted-array/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode.cn/problems/merge-sorted-array/">88. 合并两个有序数组</a>  难度: <span style="color: rgba(90, 183, 38, 1);">简单</span></p>
<p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p>
<p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。 <span id="more"></span></p>
<p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p>
<h3 id="题解">题解</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> a_len, vector&lt;<span class="keyword">int</span>&gt;&amp; b, <span class="keyword">int</span> b_len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = a_len + b_len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = a_len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = b_len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; b[k]) &#123;</span><br><span class="line">                t = a[j--];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                t = b[k--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            t = b[k--];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        a[i--] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 21. 合并两个有序链表</title>
    <url>/posts/merge-two-sorted-lists/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a>  难度: <span style="color: rgba(90, 183, 38, 1);">简单</span></p>
<p>将两个升序链表合并为一个新的 <code>升序</code> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 <span id="more"></span></p>
<h3 id="思路">思路</h3>
<p>不断来回在两条链表挑选小的节点插入合并后的链表尾。为方便第一次插入，合并前创建一个空的头结点，返回前需要将该空的头结点删除。</p>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方便第一次插入</span></span><br><span class="line">    ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">    ListNode* cur = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">            <span class="keyword">auto</span>&amp; l = l1-&gt;val &lt; l2-&gt;val ? l1 : l2;</span><br><span class="line">            cur-&gt;next = l;</span><br><span class="line">            cur = l;</span><br><span class="line">            l = l-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 剩余接在后面</span></span><br><span class="line">    cur-&gt;next = l1 ? l1 : l2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除head空节点</span></span><br><span class="line">    <span class="keyword">auto</span> tmp = head;</span><br><span class="line">    head = head-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>链表合并</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 617. 合并二叉树</title>
    <url>/posts/merge-two-binary-trees/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">617. 合并二叉树</a> 给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<span id="more"></span>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>
<h3 id="思路">思路</h3>
<p>递归处理每一节点即可</p>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root1 &amp;&amp; !root2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* n = <span class="keyword">new</span> <span class="built_in">TreeNode</span>();</span><br><span class="line">    TreeNode* l1 = <span class="literal">nullptr</span>;</span><br><span class="line">    TreeNode* r1 = <span class="literal">nullptr</span>;</span><br><span class="line">    TreeNode* l2 = <span class="literal">nullptr</span>;</span><br><span class="line">    TreeNode* r2 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (root1) &#123;</span><br><span class="line">        l1 = root1-&gt;left;</span><br><span class="line">        r1 = root1-&gt;right;</span><br><span class="line">        n-&gt;val += root1-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root2) &#123;</span><br><span class="line">        l2 = root2-&gt;left;</span><br><span class="line">        r2 = root2-&gt;right;</span><br><span class="line">        n-&gt;val += root2-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n-&gt;left = <span class="built_in">mergeTrees</span>(l1, l2);</span><br><span class="line">    n-&gt;right = <span class="built_in">mergeTrees</span>(r1, r2);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 155. 最小栈</title>
    <url>/posts/min-stack/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/min-stack/">155. 最小栈</a> 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。 <span id="more"></span></p>
<ul>
<li>push(x) —— 将元素 x 推入栈中。</li>
<li>pop() —— 删除栈顶的元素。</li>
<li>top() —— 获取栈顶元素。</li>
<li>getMin() —— 检索栈中的最小元素。</li>
</ul>
<h3 id="思路">思路</h3>
<p>由于栈是LIFO，维护一个元素和它底部的比较最小值的结构即可，它上部的值不影响这个元素处的最小值。</p>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line">        min_.<span class="built_in">push</span>(std::numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        s_.<span class="built_in">push</span>(val);</span><br><span class="line">        min_.<span class="built_in">push</span>(std::<span class="built_in">min</span>(val, min_.<span class="built_in">top</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s_.<span class="built_in">pop</span>();</span><br><span class="line">        min_.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s_.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min_.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::stack&lt;<span class="keyword">int</span>&gt; s_;</span><br><span class="line">    std::stack&lt;<span class="keyword">int</span>&gt; min_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>单调栈</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 283. 移动零</title>
    <url>/posts/move-zeroes/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/move-zeroes/">283. 移动零</a>  难度: <span style="color: rgba(90, 183, 38, 1);">简单</span></p>
<p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<span id="more"></span>
<h3 id="思路">思路</h3>
<p>todo</p>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            std::<span class="built_in">swap</span>(nums[i], nums[l]);</span><br><span class="line">            ++l;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>看过的电影</title>
    <url>/posts/movies-watched/</url>
    <content><![CDATA[<h4 id="section">2022</h4>
<ul>
<li>《加勒比海盗：黑珍珠号的诅咒》</li>
<li>《加勒比海盗2：聚魂棺》</li>
<li>《加勒比海盗3：世界的尽头》</li>
<li>《加勒比海盗4：惊涛怪浪》</li>
<li>《加勒比海盗5：死无对证》</li>
</ul>
<span id="more"></span>
<h4 id="section-1">2021</h4>
<ul>
<li>《茶馆》</li>
<li>《喊山》</li>
<li>《狮子王》</li>
<li>《牧马人》</li>
<li>《波斯》</li>
<li>《拜占庭：三城记》</li>
</ul>
<h4 id="section-2">2020</h4>
<ul>
<li>《紫陀螺》</li>
<li>《与青春有关的日子》</li>
<li>《红高粱》</li>
<li>《走出非洲》</li>
<li>《壮志凌云》</li>
<li>《双旗镇刀客》</li>
</ul>
<h4 id="b4">B4</h4>
<ul>
<li>《芙蓉镇》</li>
<li>《人生七年》</li>
<li>《变脸》</li>
<li>《罗马》</li>
<li>《那人那山那狗》</li>
<li>《野山》</li>
<li>《茶馆》</li>
<li>《城南旧事》</li>
<li>《绿皮书》</li>
<li>《free solo》</li>
<li>《波西米亚狂想曲》</li>
<li>《末代皇帝》</li>
<li>《旺角卡门》</li>
<li>《风中有朵雨做的云》 娄烨</li>
<li>《老师好》</li>
<li>《乱世佳人》</li>
<li>《哪吒》</li>
<li>《肖申克的救赎》</li>
<li>《泰坦尼克号》</li>
<li>《你的名字》</li>
<li>《秒速五厘米》</li>
<li>《西西里的美丽传说》</li>
<li>《了不起的盖茨比》</li>
<li>《千与千寻》</li>
<li>《无间道》</li>
<li>《大话西游》</li>
<li>《海上钢琴师》</li>
<li>《傲慢与偏见》</li>
<li>《怦然心动》</li>
<li>《教父》</li>
<li>《美国往事》</li>
<li>《罗马假日》</li>
<li>《情书》</li>
<li>《一天》</li>
<li>《初吻》</li>
<li>《泰坦尼克号》</li>
<li>《闻香识女人》</li>
<li>《楚门的世界》</li>
<li>《龙猫》</li>
<li>《天空之城》</li>
<li>《让子弹飞》</li>
<li>《步履不停》</li>
<li>《死亡诗社》</li>
<li>《七武士》</li>
<li>《末路狂花》</li>
<li>《阿甘正传》</li>
<li>《霸王别姬》</li>
<li>《颐和园》</li>
<li>《言叶之庭》</li>
<li>《轮回》</li>
<li>《雏菊》</li>
<li>《少年派的奇幻漂流》</li>
<li>《爱在黄昏日落时》</li>
<li>《青木瓜之味》</li>
<li>《穆赫兰道》</li>
<li>《假如爱有天意》</li>
<li>《倩女幽魂》</li>
<li>《青蛇》</li>
<li>《甜蜜蜜》</li>
<li>《笑傲江湖之东方不败》</li>
<li>《花样年华》</li>
<li>《牯岭街少年杀人》</li>
<li>《洛丽塔》</li>
<li>《天堂电影院》</li>
<li>《魂断蓝桥》</li>
<li>《罗马假日》</li>
<li>《阳光灿烂的日子》</li>
<li>《少年时代》</li>
<li>《两小无猜》</li>
<li>《剪刀手爱德华》</li>
<li>《放牛班的春天》</li>
<li>《我脑海里的橡皮擦》</li>
<li>《菊次郎的春天》</li>
<li>《坏孩子的天空》</li>
<li>《燕尾蝶》</li>
<li>《花与爱丽丝》</li>
<li>《纵横四海》</li>
<li>《活着》</li>
<li>《春风沉醉的夜晚》</li>
<li>《指环王》</li>
<li>《哈利波特》</li>
<li>《加勒比海盗》</li>
<li>《乱世佳人》</li>
<li>《尘与雪》</li>
<li>《大鸿米店》</li>
<li>《天浴》</li>
<li></li>
</ul>
]]></content>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title>下一个排列</title>
    <url>/posts/next-permutation/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/next-permutation/">31. 下一个排列</a> 实现获取<code>下一个排列</code>的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列（即，组合出下一个更大的整数）。</p>
<span id="more"></span>
<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>
<p>必须<code>原地</code>修改，只允许使用额外常数空间。</p>
<h3 id="思路">思路</h3>
<p>首先，考虑如何变换出比当前更大的排列：由于十进制数从右往左数位逐渐变大，所以将一个大数和一个在它左侧且比它小的数交换即可。 其次，考虑如何是下一个更大的排列（也就是尽可能的小），同样由于十进制数从右往左数位逐渐变大，所以我们尽可能将靠近右侧的符合要求的数交换。</p>
<p>那我们从右往左找拐点（由大变小的那个大数），拐点变小的那个数我们要交换到右边一个比它大的数（且尽可能小），交换后，再将拐点右侧的数调整成升序（尽可能小）</p>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找拐点</span></span><br><span class="line">    <span class="keyword">auto</span> l_iter = std::<span class="built_in">is_sorted_until</span>(nums.<span class="built_in">rbegin</span>(), nums.<span class="built_in">rend</span>());</span><br><span class="line">    <span class="comment">// 不存在拐点则已经是最大的排列，按题目要求升序</span></span><br><span class="line">    <span class="keyword">if</span> (l_iter == nums.<span class="built_in">rend</span>()) &#123;</span><br><span class="line">        std::<span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找右尽可能小且大于l_iter的数和l_iter进行交换</span></span><br><span class="line">    <span class="keyword">auto</span> r_iter = std::<span class="built_in">upper_bound</span>(nums.<span class="built_in">rbegin</span>(), l_iter, *l_iter);</span><br><span class="line">    std::<span class="built_in">iter_swap</span>(l_iter, r_iter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// base() refers to the element that is next of l_iter pointing to</span></span><br><span class="line">    std::<span class="built_in">sort</span>(l_iter.<span class="built_in">base</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 292. Nim游戏</title>
    <url>/posts/nim-game/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/next-permutation/">292. Nim游戏</a> 你和你的朋友，两个人一起玩 Nim 游戏：<br />
<span id="more"></span> 桌子上有一堆石头。<br />
你们轮流进行自己的回合，你作为先手。<br />
每一回合，轮到的人拿掉 1 - 3 块石头。<br />
拿掉最后一块石头的人就是获胜者。<br />
假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 n 的情况下赢得游戏。如果可以赢，返回 true；否则，返回 false 。</p>
<h3 id="思路">思路</h3>
<p>这是一个零和游戏（Zero-sum Game），是博弈论（gametheory）的一个概念。零和游戏也叫零和博弈，指的是两人对弈，总有一方赢（计分为1）、一方输（计分为-1），总和是0。在游戏中，双方都会选择对自己最有益的策略</p>
<p>假设有1块石头，直接拿走1块，己方赢<br />
假设有2块石头，直接拿走2块，己方赢<br />
假设有3块石头，直接拿走3块，己方赢</p>
<p>假设有4块石头，若拿1块、2块、3块，剩余分别是3块、2块、1块，对方赢</p>
<p>假设有5块石头，下轮可能是上4中情况，不想让对方赢，只有让下轮4块，本轮拿1块，己方赢 ...</p>
<p>一个回合指己方拿一次，对方拿一次。每个回合各方可拿走的石头块数可能是1、2、3，每个回合总能凑出4块(1+3、2+2、3+1)，是谁拿到最后一块石头就是一件确定的事情。零和博弈的前提是双方都会寻找自己的最优解。石头数是n，己方先手： 1）若n能被4整除，对方只要控制每个回合拿走4块石头，那最后一手一定是对方 2）若n不能被4整除，相当于给了己方一次调整机会，第一次先手时将石头数调整为4的倍数，同1）理，则最后一手一定是己方。</p>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canWinNim</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n % <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 328. 奇偶链表</title>
    <url>/posts/odd-even-linked-list/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/odd-even-linked-list/">328. 奇偶链表</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给定单链表的头节点 head ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。 <span id="more"></span></p>
<p>第一个节点的索引被认为是 奇数 ， 第二个节点的索引为 偶数 ，以此类推。</p>
<p>请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。</p>
<p>你必须在 O(1) 的额外空间复杂度和 O(n) 的时间复杂度下解决这个问题。</p>
<h3 id="题解">题解</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode odd;</span><br><span class="line">    ListNode even;</span><br><span class="line">    ListNode* op = &amp;odd;</span><br><span class="line">    ListNode* ep = &amp;even;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">        <span class="keyword">if</span> (++i % <span class="number">2</span>) &#123;</span><br><span class="line">            ep-&gt;next = head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            ep = ep-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            op-&gt;next = head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            op = op-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    op-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    ep-&gt;next = odd.next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> even.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 234. 回文链表</title>
    <url>/posts/palindrome-linked-list/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/palindrome-linked-list/">234. 回文链表</a>  难度: <span style="color: rgba(90, 183, 38, 1);">简单</span></p>
<p>给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。</p>
<span id="more"></span>
<h3 id="思路">思路</h3>
<p>todo</p>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> reverseList = [](ListNode* head) &#123;</span><br><span class="line">        ListNode l;</span><br><span class="line"></span><br><span class="line">        ListNode* n = head;</span><br><span class="line">        ListNode* t = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            t = n-&gt;next;</span><br><span class="line">            n-&gt;next = l.next;</span><br><span class="line">            l.next = n;</span><br><span class="line">            n = t;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> l.next;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    // 通过记数法找到一般的位置</span></span><br><span class="line"><span class="comment">    int len = 0;</span></span><br><span class="line"><span class="comment">    ListNode* p1 = head;</span></span><br><span class="line"><span class="comment">    while (p1) &#123;</span></span><br><span class="line"><span class="comment">        ++len;</span></span><br><span class="line"><span class="comment">        p1 = p1-&gt;next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    p1 = head;</span></span><br><span class="line"><span class="comment">    len = (len + 1) / 2;</span></span><br><span class="line"><span class="comment">    while (len &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">        --len;</span></span><br><span class="line"><span class="comment">        p1 = p1-&gt;next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    p1 = reverseList(p1);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过快慢指针找到一半的位置</span></span><br><span class="line">    ListNode* fast = head;</span><br><span class="line">    ListNode* slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* p1 = slow-&gt;next;</span><br><span class="line">    p1 = <span class="built_in">reverseList</span>(p1);</span><br><span class="line"></span><br><span class="line">    ListNode* p0 = head;</span><br><span class="line">    <span class="keyword">while</span> (p1) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p0-&gt;val != p1-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p1 = p1-&gt;next;</span><br><span class="line">        p0 = p0-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p1 == <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 437. 路径总和 III</title>
    <url>/posts/path-sum-iii/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode.cn/problems/path-sum-iii/">437. 路径总和 III</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。</p>
<p>路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。 <span id="more"></span></p>
<h3 id="题解">题解</h3>
<h4 id="前缀和">前缀和</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度 O(N)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> target, <span class="keyword">long</span> prefixSum, <span class="keyword">int</span>&amp; cnt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        prefixSum += root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (prefixSum == target) &#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> it = prefixSumCount.<span class="built_in">find</span>(prefixSum - target);</span><br><span class="line">        <span class="keyword">if</span> (it != prefixSumCount.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            cnt += it-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ++prefixSumCount[prefixSum];</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, target, prefixSum, cnt);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right, target, prefixSum, cnt);</span><br><span class="line">        --prefixSumCount[prefixSum];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root, targetSum, <span class="number">0</span>, cnt);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::unordered_map&lt;<span class="keyword">long</span>, <span class="keyword">int</span>&gt; prefixSumCount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="双重递归">双重递归</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度 O(N^2)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">long</span> target, <span class="keyword">int</span>&amp; cnt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    target -= root-&gt;val;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;left, target, cnt);</span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;right, target, cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(root, targetSum, cnt);</span><br><span class="line">    cnt += <span class="built_in">pathSum</span>(root-&gt;left, targetSum);</span><br><span class="line">    cnt += <span class="built_in">pathSum</span>(root-&gt;right, targetSum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
        <tag>双重递归</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 416. 分隔等和子集</title>
    <url>/posts/partition-equal-subset-sum/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">LeetCode 416. 分隔等和子集</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 <span id="more"></span></p>
<h3 id="思路">思路</h3>
<h4 id="深度优先">深度优先</h4>
<p>和<a href="/posts/target-sum/">141. 环形链表</a>同样的思路。</p>
<ul>
<li>时间复杂度O(2^n)。二叉树的深度为数组长度n，所有节点都需要遍历，因此节点数代表了时间复杂度。</li>
<li>空间复杂度O(n)。空间复杂度取决于递归调用的栈空间，栈深度为数组长度n。</li>
</ul>
<p>提交结果 <code>超出时间限制</code>。二叉树搜索的过程中我们加上缓存，将步骤index和目标targe作为key，如果之前在同样的步骤遇到过这种target，可以直接返回。</p>
<p>index和target同时作为key，对于std::unordered_map需要提供专门的hash函数，为了省事有两种方法：</p>
<ul>
<li>std::vector&lt;std::unordered_map&lt;int, bool&gt;&gt;，其中，数组下标是步骤，hash表的key是target</li>
<li>由于nums和nums[i]都比较小，所以可以用一个int做hash的key，高16位存步骤，低16位存target</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; nums, std::unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt;&amp; cache, <span class="keyword">int</span> index, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> it = cache.<span class="built_in">find</span>(index &lt;&lt; <span class="number">16</span> | target);</span><br><span class="line">    <span class="keyword">if</span> (it != cache.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> ret = <span class="built_in">dfs</span>(nums, cache, index+<span class="number">1</span>, target+nums[index]) || <span class="built_in">dfs</span>(nums, cache, index+<span class="number">1</span>, target);</span><br><span class="line">    cache.<span class="built_in">insert</span>(&#123;index &lt;&lt; <span class="number">16</span> | target, ret&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = std::<span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; cache;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(nums, cache, <span class="number">0</span>, -sum / <span class="number">2</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="动态规划">动态规划</h4>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 647. 回文子串</title>
    <url>/posts/palindromic-substrings/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/palindromic-substrings/">647. 回文子串</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给你一个字符串 <code>s</code> ，请你统计并返回这个字符串中 <code>回文子串</code> 的数目。 <span id="more"></span></p>
<p>回文字符串 是正着读和倒过来读一样的字符串。</p>
<p>子字符串 是字符串中的由连续字符组成的一个序列。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>
<h3 id="思路">思路</h3>
<p>中心展开检查是否满足回文字符，考虑奇数或偶数个字符，中心位置总共有 <code>2*n-1</code> 个，分别是： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0  </span><br><span class="line">0 1  </span><br><span class="line">1 1  </span><br><span class="line">1 0  </span><br><span class="line">...</span><br></pre></td></tr></table></figure> 也就是 l = i / 2, r = i/2 + i%2</p>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n*<span class="number">2</span><span class="number">-1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = i / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> r = i / <span class="number">2</span> + i % <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (l&gt;=<span class="number">0</span> &amp;&amp; r&lt;n &amp;&amp; s[l] == s[r]) &#123;</span><br><span class="line">            ++ans;</span><br><span class="line">            --l;</span><br><span class="line">            ++r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 279. 完全平方数</title>
    <url>/posts/perfect-squares/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode.cn/problems/perfect-squares/">279. 完全平方数</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。 <span id="more"></span></p>
<p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p>
<h3 id="题解">题解</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = std::numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j*j&lt;=i; ++j) &#123;</span><br><span class="line">            min = std::<span class="built_in">min</span>(min, dp[i-j*j]);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = <span class="number">1</span> + min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 200. 岛屿数量</title>
    <url>/posts/number-of-islands/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给你一个由 <code>'1'</code>（陆地）和 <code>'0'</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。 <span id="more"></span></p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<h3 id="思路">思路</h3>
<p>遍历每一个节点：</p>
<ul>
<li>如果该节不是 <code>1</code> 退出遍历 岛屿数 <code>+0</code>。</li>
<li>否则，将该点置为 <code>2</code>（避免再次遍历），递归遍历其上、下、左、右节点，和这个节点相连的都会被置为 <code>2</code>。遍历结束 岛屿数 <code>+1</code>。</li>
</ul>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; i &lt; grid.<span class="built_in">size</span>() &amp;&amp; j &lt; grid[i].<span class="built_in">size</span>() &amp;&amp; grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">        grid[i][j] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(grid, i<span class="number">-1</span>, j);</span><br><span class="line">        <span class="built_in">dfs</span>(grid, i+<span class="number">1</span>, j);</span><br><span class="line">        <span class="built_in">dfs</span>(grid, i, j<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(grid, i, j+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;grid.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;grid[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            ans += <span class="built_in">dfs</span>(grid, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>dfs</tag>
        <tag>深度优先</tag>
        <tag>并查集</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 46. 全排列</title>
    <url>/posts/permutations/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a> 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。 <span id="more"></span></p>
<h3 id="思路">思路</h3>
<p>c++ algorithm库函数next_permutation，其可能实现参考<a href="/posts/next-permutation/">31. 下一个排列</a></p>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt; all;</span><br><span class="line">    std::<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        all.<span class="built_in">push_back</span>(nums);</span><br><span class="line">    &#125; <span class="keyword">while</span> (std::<span class="built_in">next_permutation</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 50. Pow(x, n)</title>
    <url>/posts/powx-n/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode.cn/problems/powx-n/">50. Pow(x, n)</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>实现 <code>pow(x, n)</code> ，即计算 <code>x</code> 的整数 <code>n</code> 次幂函数（即，<code>x^n</code> ）。 <span id="more"></span></p>
<h3 id="题解">题解</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> N = n;</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> / <span class="built_in">quickMul</span>(x, -N);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">quickMul</span>(x, N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一、递归 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> y = <span class="built_in">quickMul</span>(x, n/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> y*y;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> y*y*x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>二、迭代 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> N =  n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> y = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (N) &#123;</span><br><span class="line">        <span class="keyword">if</span> (N &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            y *= x;</span><br><span class="line">        &#125;</span><br><span class="line">        x *= x;</span><br><span class="line">        N = N &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 326. 3的幂</title>
    <url>/posts/power-of-three/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/power-of-three/">326. 3的幂</a></p>
<p>给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 true ；否则，返回 false 。<br />
<span id="more"></span> 整数 <span class="math inline">\(n\)</span> 是 3 的幂次方需满足：存在整数 <span class="math inline">\(x\)</span> 使得 <span class="math inline">\(n==3^x\)</span></p>
<h3 id="思路">思路</h3>
<h4 id="解法一">解法一</h4>
<p>任何整数的0次幂都为1，对0做特殊处理。<br />
整数 <span class="math inline">\(n\)</span> 是 3 的幂次方满足两个条件：</p>
<ul>
<li>不断可以整除3</li>
<li>最后剩余1</li>
</ul>
<h4 id="解法二">解法二</h4>
<p>参考LeetCode官方一种取巧的思路</p>
<blockquote>
<p>在题目给定的 3232 位有符号整数的范围内，最大的 3 的幂为 <span class="math inline">\(3^{19} = 11622614673\)</span>。我们只需要判断 n 是否是 <span class="math inline">\(3^{19}\)</span> 的约数即可。</p>
</blockquote>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        n /= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/posts/quick-sort/</url>
    <content><![CDATA[<p><a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><code>快速排序</code></a>（Quicksor）由东尼·霍尔提出。是一种平均时间复杂度为 <span class="math inline">\(O(n\log n)\)</span> 的排序算法。 <span id="more"></span></p>
<h3 id="原理">原理</h3>
<p><code>快排</code> 是分治的思想。对于一个排序问题，将一个元素放在 <code>正确位置</code>（大于等于左侧元素，小于等于右侧元素），而该元素将序列拆分为两部分，再在各部分子问题继续求解。</p>
<p>每次将一个元素放在正确位置耗时为 <span class="math inline">\(n\)</span>，假设每次拆分都是长度比较接近的两部分，那么拆分的子问题个数为 <span class="math inline">\(\log n\)</span>，所以时间复杂度为 <span class="math inline">\(O(n\log n)\)</span>；如果每次拆分的一个子问题长度接近 <span class="math inline">\(n\)</span>，时间复杂度为 <span class="math inline">\(O(n^2)\)</span>。</p>
<h3 id="算法">算法</h3>
<h4 id="partition">Partition</h4>
<p>将一个元素放在 <code>正确位置</code> 的步骤称为 <code>Partition</code>，是快排的核心。这个元素也称为基准（pivot），具体过程：</p>
<ol type="1">
<li>挑选基准（可随机挑选，避免拆分不均）</li>
<li>分割序列</li>
<li>返回基准</li>
</ol>
<p>其中，分割序列是将小于基准的元素调整到它的左侧，大于基准的元素调整到它的右侧。假设挑选的基准是序列最右的元素，我们从左往右遍历元素至基准。在遍历过程中，维护一个lower_bound，保证它右侧值都大于等于基准，否则将其和右侧值交换，并将lower_bound++。这样，遍历结束时lower_bound左侧的都小于基准，lower_bound就是基准应该调整到的位置。</p>
<h4 id="递归调用">递归调用</h4>
<p>对于快排来说，就是不断进行 <code>Partition</code> ，再递归对左区间和右区间进行排序，直到区间大小为1。</p>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; vec, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// right 基准</span></span><br><span class="line">    <span class="comment">// lower_bound 大于等于基准</span></span><br><span class="line">    <span class="keyword">int</span> lower_bound = low;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=low; i&lt;high; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vec[i] &lt; vec[high]) &#123;</span><br><span class="line">            std::<span class="built_in">swap</span>(vec[lower_bound], vec[i]);</span><br><span class="line">            ++lower_bound;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">swap</span>(vec[lower_bound], vec[high]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lower_bound;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; vec, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt;= high) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> bound = <span class="built_in">partition</span>(vec, low, high);</span><br><span class="line">    <span class="built_in">quick_sort</span>(vec, low, bound<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">quick_sort</span>(vec, bound+<span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">quick_sort</span>(v, <span class="number">0</span>, v.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    std::for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="keyword">int</span>&amp; n)&#123;</span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>排序算法</tag>
        <tag>快排</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 406. 根据身高重建队列</title>
    <url>/posts/queue-reconstruction-by-height/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">406. 根据身高重建队列</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>假设有打乱顺序的一群人站成一个队列，数组 <code>people</code> 表示队列中一些人的属性（不一定按顺序）。每个 <code>people[i] = [hi, ki]</code> 表示第 <code>i</code> 个人的身高为 <code>hi</code> ，前面 <code>正好</code> 有 <code>ki</code> 个身高大于或等于 <code>hi</code> 的人。 <span id="more"></span></p>
<p>请你重新构造并返回输入数组 <code>people</code> 所表示的队列。返回的队列应该格式化为数组 <code>queue</code> ，其中 <code>queue[j] = [hj, kj]</code> 是队列中第 <code>j</code> 个人的属性（<code>queue[0]</code> 是排在队列前面的人）。</p>
<h3 id="解法">解法</h3>
<p>直觉告诉我们应该将其按照身高进行排序以简化复杂性。排序后我们可以由高到低，也可以由低到高进行分析。</p>
<h4 id="一由高到低">一、由高到低</h4>
<p>这种思路就是预先固定高的人的位置，因为低的人不会影响已经固定的高的人间相对顺序。需要注意的是：同样高度的，<code>比自己高的个数</code>小的先固定。在实现中由于后处理的元素要在处理过的序列中找到合适位置（足够多个大于等于它），存在插入操作，另外为了减少排序耗时，构造一个link，同时作为一个符号表，对其进行排序和删除插入，最后再映射回原始数据。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">resort</span>(std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">    <span class="comment">// 构造链表link，方便插入删除，也充当symbol table角色</span></span><br><span class="line">    <span class="function">std::list&lt;<span class="keyword">int</span>&gt; <span class="title">link</span><span class="params">(people.size())</span></span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; n: link) &#123;</span><br><span class="line">        n = num++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序：第一维由大-&gt;小  第二维由小-大</span></span><br><span class="line">    link.<span class="built_in">sort</span>([&amp;people](<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">        <span class="keyword">auto</span> u = people[i];</span><br><span class="line">        <span class="keyword">auto</span> v = people[j];</span><br><span class="line">        <span class="keyword">return</span> u[<span class="number">0</span>] &gt; v[<span class="number">0</span>] || (u[<span class="number">0</span>] == v[<span class="number">0</span>] &amp;&amp; u[<span class="number">1</span>] &lt; v[<span class="number">1</span>]);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = link.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (it != link.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        num = people[*it][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            ++it;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> bound = it;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            --bound;</span><br><span class="line">        &#125; <span class="keyword">while</span> (--num &gt; <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        link.<span class="built_in">insert</span>(bound, *it);</span><br><span class="line">        it = link.<span class="built_in">erase</span>(it);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对link进行reverse即是答案</span></span><br><span class="line">    num = <span class="number">0</span>;</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">ans</span>(people.<span class="built_in">size</span>());</span><br><span class="line">    std::for_each(link.<span class="built_in">rbegin</span>(), link.<span class="built_in">rend</span>(), [&amp;people, &amp;ans, &amp;num](<span class="keyword">int</span>&amp; n) &#123;</span><br><span class="line">        ans[num++] = people[n];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二由低到高">二、由低到高</h4>
<p>从矮个子处理，为每个矮个前预留高个的个数 以确定矮个具体位置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">resort2</span>(std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">    std::<span class="built_in">sort</span>(people.<span class="built_in">begin</span>(), people.<span class="built_in">end</span>(), [](std::vector&lt;<span class="keyword">int</span>&gt;&amp; u, std::vector&lt;<span class="keyword">int</span>&gt;&amp; v) &#123;</span><br><span class="line">        <span class="keyword">return</span> u[<span class="number">0</span>] &lt; v[<span class="number">0</span>] || (u[<span class="number">0</span>] == v[<span class="number">0</span>] &amp;&amp; u[<span class="number">1</span>] &gt; v[<span class="number">1</span>]);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">ans</span>(people.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; u: people) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// 从头遍历</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">// 预留个数</span></span><br><span class="line">        <span class="keyword">while</span> (j &lt; u[<span class="number">1</span>] || !ans[i].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans[i].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[i] = u;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 238. 除自身以外数组的乘积</title>
    <url>/posts/product-of-array-except-self/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode.cn/problems/product-of-array-except-self/">238. 除自身以外数组的乘积</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。 <span id="more"></span></p>
<p>题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。</p>
<p>请不要使用除法，且在 O(n) 时间复杂度内完成此题。</p>
<h3 id="题解">题解</h3>
<p>如果使用除法，一次求得所有元素乘积P，answer[i] = P / nums[i]即可，但题目要求不用除法。</p>
<p>一、分别求前缀和后缀积，额外的空间复杂度 O(n) <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">forward_p</span><span class="params">(size+<span class="number">2</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">backward_p</span><span class="params">(size+<span class="number">2</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1, size</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; ++i) &#123;</span><br><span class="line">        forward_p[i+<span class="number">1</span>] = forward_p[i] * nums[i];</span><br><span class="line">        backward_p[size-i] = backward_p[size-i+<span class="number">1</span>] * nums[size-i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// forward_p可以优化掉</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(size, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; ++i) &#123;</span><br><span class="line">        ans[i] = forward_p[i] * backward_p[i+<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>进阶：你可以在 O(1) 的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）</p>
<p>二、在（方法一）forward_p可以优化，再利用输出数组 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">prod</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 由前往后遍历，前缀可以逐步计算</span></span><br><span class="line">    <span class="comment">// 后缀存储在prod</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=nums.<span class="built_in">size</span>()<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        prod[i] = prod[i+<span class="number">1</span>] * nums[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l_prod = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        prod[i] = l_prod * prod[i];</span><br><span class="line">        l_prod = l_prod * nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>三、一种更巧妙的解法<br />
<a href="https://leetcode.cn/problems/product-of-array-except-self/comments/59944/">C++ 左右累乘，巧妙记录每个元素的左右乘积</a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>加一</title>
    <url>/posts/plus-one/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/plus-one/">66. 加一</a> 给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">plusOne</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (digits.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">sums</span><span class="params">(digits.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=digits.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = digits[i] + sums[i] + carry;</span><br><span class="line">        sums[i] =  sum % <span class="number">10</span>;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry) &#123;</span><br><span class="line">        sums.<span class="built_in">insert</span>(sums.<span class="built_in">begin</span>(), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 223. 矩形面积</title>
    <url>/posts/rectangle-area/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/rectangle-area/">223. 矩形面积</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给你 二维 平面上两个 由直线构成的 矩形，请你计算并返回两个矩形覆盖的总面积。 <span id="more"></span></p>
<p>每个矩形由其 <code>左下</code> 顶点和 <code>右上</code> 顶点坐标表示：</p>
<ul>
<li>第一个矩形由其左下顶点 <span class="math inline">\((ax1, ay1)\)</span> 和右上顶点 <span class="math inline">\((ax2, ay2)\)</span> 定义。</li>
<li>第二个矩形由其左下顶点 <span class="math inline">\((bx1, by1)\)</span> 和右上顶点 <span class="math inline">\((bx2, by2)\)</span> 定义。</li>
</ul>
<h3 id="思路">思路</h3>
<p>两个矩形覆盖的面积等于：两个矩形面积的和减去重叠面积。如何计算重叠面积？</p>
<h4 id="情况判断">情况判断</h4>
<p><span class="math inline">\(x\)</span>轴重叠长度乘<span class="math inline">\(y\)</span>轴重叠长度。如何计算重叠长度？ 考虑<span class="math inline">\(x\)</span>轴，存在以下几种情况：</p>
<p><img data-src="https://z3.ax1x.com/2021/10/10/5E5jAA.png" /> 其中②③④⑥场景存在重叠。</p>
<p><span class="math inline">\(y\)</span>轴同理。</p>
<h4 id="规律总结">规律总结</h4>
<p><span class="math inline">\(ax2\)</span>和<span class="math inline">\(bx2\)</span>较小者记为<span class="math inline">\(top\)</span></p>
<p><span class="math inline">\(ax1\)</span>和<span class="math inline">\(bx1\)</span>较大者记为<span class="math inline">\(bottom\)</span></p>
<p><span class="math inline">\(bottom\)</span>到<span class="math inline">\(top\)</span>的正向距离即是重叠长度。</p>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">computeArea</span><span class="params">(<span class="keyword">int</span> ax1, <span class="keyword">int</span> ay1, <span class="keyword">int</span> ax2, <span class="keyword">int</span> ay2, <span class="keyword">int</span> bx1, <span class="keyword">int</span> by1, <span class="keyword">int</span> bx2, <span class="keyword">int</span> by2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> overlap = [](<span class="keyword">int</span> ax1, <span class="keyword">int</span> ax2, <span class="keyword">int</span> bx1, <span class="keyword">int</span> bx2) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 情况判断</span></span><br><span class="line"><span class="comment">         * if (bx2&gt;=ax2 &amp;&amp; ax2&gt;=bx1 &amp;&amp; bx1&gt;=ax1) &#123;</span></span><br><span class="line"><span class="comment">         *     return ax2 - bx1;</span></span><br><span class="line"><span class="comment">         * &#125;</span></span><br><span class="line"><span class="comment">         * if (ax2&gt;=bx2 &amp;&amp; bx1&gt;=ax1) &#123;</span></span><br><span class="line"><span class="comment">         *     return bx2 - bx1;</span></span><br><span class="line"><span class="comment">         * &#125;</span></span><br><span class="line"><span class="comment">         * if (bx2&gt;=ax2 &amp;&amp; ax1&gt;=bx1) &#123;</span></span><br><span class="line"><span class="comment">         *     return ax2 - ax1;</span></span><br><span class="line"><span class="comment">         * &#125;</span></span><br><span class="line"><span class="comment">         * if (ax2&gt;=bx2 &amp;&amp; bx2&gt;=ax1 &amp;&amp; ax1&gt;=bx1) &#123;</span></span><br><span class="line"><span class="comment">         *     return bx2 - ax1;</span></span><br><span class="line"><span class="comment">         * &#125;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * return 0;</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 规律总结</span></span><br><span class="line">        <span class="keyword">int</span> top = std::<span class="built_in">min</span>(ax2, bx2);</span><br><span class="line">        <span class="keyword">int</span> bottom = std::<span class="built_in">max</span>(ax1, bx1);</span><br><span class="line">        <span class="keyword">if</span> (top &lt; bottom) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> top - bottom;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> w = <span class="built_in">overlap</span>(ax1, ax2, bx1, bx2);</span><br><span class="line">    <span class="keyword">int</span> h = <span class="built_in">overlap</span>(ay1, ay2, by1, by2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (ax2-ax1) * (ay2-ay1) + (bx2-bx1) * (by2-by1) - w * h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 398. 随机数索引</title>
    <url>/posts/random-pick-index/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode.cn/problems/random-pick-index/">398. 随机数索引</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给你一个可能含有 重复元素 的整数数组 nums ，请你随机输出给定的目标数字 target 的索引。你可以假设给定的数字一定存在于数组中。 <span id="more"></span></p>
<p>实现 <code>Solution</code> 类：</p>
<ul>
<li><code>Solution(int[] nums)</code> 用数组 <code>nums</code> 初始化对象。</li>
<li><code>int pick(int target)</code> 从 <code>nums</code> 中选出一个满足 <code>nums[i] == target</code> 的随机索引 <code>i</code> 。如果存在多个有效的索引，则每个索引的返回概率应当相等。</li>
</ul>
<h3 id="题解">题解</h3>
<p>一、哈希表统计 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Solution</span>(std::vector&lt;<span class="keyword">int</span>&gt;&amp; nums) : <span class="built_in">e</span>(<span class="built_in">rd</span>()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            num2index[nums[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pick</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = num2index.<span class="built_in">find</span>(target);</span><br><span class="line">        <span class="keyword">if</span> (it == num2index.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> it-&gt;second[<span class="built_in">u</span>(e) % it-&gt;second.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::random_device rd;</span><br><span class="line">    std::default_random_engine e;</span><br><span class="line">    std::uniform_int_distribution&lt;<span class="keyword">int</span>&gt; u;</span><br><span class="line"></span><br><span class="line">    std::unordered_map&lt;<span class="keyword">int</span>, std::vector&lt;<span class="keyword">int</span>&gt;&gt; num2index;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>二、蓄水池采样 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Solution</span>(std::vector&lt;<span class="keyword">int</span>&gt;&amp; nums) : <span class="built_in">nums</span>(nums), <span class="built_in">e</span>(<span class="built_in">rd</span>()) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pick</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == target) &#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">u</span>(e) % cnt == <span class="number">0</span>) &#123;</span><br><span class="line">                    ans = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt;&amp; nums;</span><br><span class="line"></span><br><span class="line">    std::random_device rd;</span><br><span class="line">    std::default_random_engine e;</span><br><span class="line">    std::uniform_int_distribution&lt;<span class="keyword">int</span>&gt; u;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>蓄水池采样</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 92. 反转链表 II</title>
    <url>/posts/reverse-linked-list-ii/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode.cn/problems/reverse-linked-list-ii/">92. 反转链表 II</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</p>
<span id="more"></span>
<h3 id="题解">题解</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="function">ListNode <span class="title">l</span><span class="params">(<span class="number">0</span>, head)</span></span>;</span><br><span class="line">    head = &amp;l;</span><br><span class="line">    <span class="keyword">int</span> len = right - left + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left-- &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode* p = head-&gt;next;</span><br><span class="line">    ListNode* e = p;</span><br><span class="line">    ListNode* t;</span><br><span class="line">    <span class="keyword">while</span> (len-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        t = p-&gt;next;</span><br><span class="line">        p-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next = p;</span><br><span class="line">        p = t;</span><br><span class="line">    &#125;</span><br><span class="line">    e-&gt;next = p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> l.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 190. 颠倒二进制位</title>
    <url>/posts/reverse-bits/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode.cn/problems/reverse-bits/">190. 颠倒二进制位</a>  难度: <span style="color: rgba(90, 183, 38, 1);">简单</span></p>
<p>颠倒给定的 32 位无符号整数的二进制位。 <span id="more"></span></p>
<h3 id="题解">题解</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> bit = (n &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        ans |= bit &lt;&lt; (<span class="number">31</span>-i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 48. 旋转图像</title>
    <url>/posts/rotate-image/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/rotate-image/">48. 旋转图像</a> 给定一个 <span class="math inline">\(n×n\)</span> 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转<span class="math inline">\(90\)</span>度。<br />
<span id="more"></span> 你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p>
<h3 id="思路">思路</h3>
<p>对于<span class="math inline">\(n*n\)</span>的矩阵顺时针旋转<span class="math inline">\(90\)</span>度，通过模拟的方法，对于每个元素顺时针移动<span class="math inline">\(n\)</span>个元素即可。我们逆时针依次进行交换，前<span class="math inline">\(n\)</span>个被交换元素在最后一次被交换到正确的位置。由于存在多层，每层4条边，需逐层旋转遍历逻辑。</p>
<p>在二维直角坐标系中将一个坐标<span class="math inline">\((i,j)\)</span>顺时针旋转<span class="math inline">\(90^{\circ}\)</span>，可以通过沿<span class="math inline">\(y=x\)</span>折叠，再沿<span class="math inline">\(y=0\)</span>折叠得到。将旋转转换为两次折叠的好处在于，折叠意味着按顺序交换，避免复杂遍历逻辑。考虑第一象限的坐标</p>
<ul>
<li>坐标<span class="math inline">\((i,j)\)</span>沿<span class="math inline">\(y=x\)</span>对折后坐标为<span class="math inline">\((j,i)\)</span></li>
<li>坐标<span class="math inline">\((i,j)\)</span>沿<span class="math inline">\(y=0\)</span>对折后坐标为<span class="math inline">\((i,-j)\)</span></li>
</ul>
<p>在矩阵中，可以先将其沿主对角线对折，再左右对折。沿主对角线折叠时索引<span class="math inline">\([i,j]\)</span>和<span class="math inline">\([j,i]\)</span>交换。左右对折时，索引<span class="math inline">\([i,j]\)</span>和<span class="math inline">\([i,n-1-j]\)</span>交换</p>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 对角对折</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>+i; j&lt;n; ++j) &#123;</span><br><span class="line">            std::<span class="built_in">swap</span>(matrix[i][j], matrix[j][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左右对折</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n/<span class="number">2</span>; ++j) &#123;</span><br><span class="line">            std::<span class="built_in">swap</span>(matrix[i][j],matrix[i][n<span class="number">-1</span>-j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 100. 相同的树</title>
    <url>/posts/same-tree/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode.cn/problems/same-tree/">100. 相同的树</a>  难度: <span style="color: rgba(90, 183, 38, 1);">简单</span></p>
<p>给你两棵二叉树的根节点 <code>p</code> 和 <code>q</code> ，编写一个函数来检验这两棵树是否相同。</p>
<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 <span id="more"></span></p>
<h3 id="题解">题解</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p || !q) &#123;</span><br><span class="line">        <span class="keyword">return</span>  p ==  q;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p-&gt;val == q-&gt;val &amp;&amp; <span class="built_in">isSameTree</span>(p-&gt;left, q-&gt;left) &amp;&amp; <span class="built_in">isSameTree</span>(p-&gt;right, q-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 73. 矩阵置零</title>
    <url>/posts/set-matrix-zeroes/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/set-matrix-zeroes/">73. 矩阵置零</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。 <span id="more"></span></p>
<h3 id="题解">题解</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> row0 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[<span class="number">0</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">            row0 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;m; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            matrix[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=m<span class="number">-1</span>; i&gt;<span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=n<span class="number">-1</span>; j&gt;<span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span> || matrix[<span class="number">0</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (matrix[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; ++i) &#123;</span><br><span class="line">            matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (row0) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; ++j) &#123;</span><br><span class="line">            matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 240. 搜索二维矩阵 II</title>
    <url>/posts/search-a-2d-matrix-ii/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>编写一个高效的算法来搜索 <code>m x n</code> 矩阵 <code>matrix</code> 中的一个目标值 <code>target</code> 。该矩阵具有以下特性：</p>
<ul>
<li>每行的元素从左到右升序排列。</li>
<li>每列的元素从上到下升序排列。 <span id="more"></span></li>
</ul>
<h3 id="思路">思路</h3>
<p><strong>一、Z形搜索</strong> 我们从矩阵右上角开始搜索，如果大于target向左走，如果小于target向下走，存在target最多m+n步就可以搜索到，任意方向走出边界说明target不存在。</p>
<p><strong>二、类二分查找</strong> 观察矩阵从左向右递增，从上向下底层，很容易想到二分查找。由于是矩阵，所以每次会将矩阵从中心分成4分，一定能够排除其中的一份。在现实需要注意边界条件。</p>
<h3 id="实现">实现</h3>
<p><strong>Z形搜索</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; matrix.<span class="built_in">size</span>() &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target == matrix[i][j]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; matrix[i][j]) &#123;</span><br><span class="line">            --j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>类二分查找</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">b_search</span><span class="params">(std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="keyword">int</span> y2, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target &lt; matrix[x1][y1] || target &gt; matrix[x2][y2]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> xm = (x2 + x1) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> ym = (y2 + y1) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (target == matrix[xm][ym]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 分成的4个矩阵边界处不要有重叠，否则死循环，y2&gt;ym就是避免重叠的。</span></span><br><span class="line"><span class="comment">    比如：</span></span><br><span class="line"><span class="comment">        1 2</span></span><br><span class="line"><span class="comment">        3 4</span></span><br><span class="line"><span class="comment">    后三种情况不要b_search前的条件，对角1,4这个矩形就不断迭代，因为第四部分又是和输入是一个矩形</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">b_search</span>(matrix, x1, y1, xm, ym, target) ||</span><br><span class="line">        (y2&gt;ym &amp;&amp; <span class="built_in">b_search</span>(matrix, x1, ym+<span class="number">1</span>, xm, y2, target)) ||</span><br><span class="line">        (x2&gt;xm &amp;&amp; <span class="built_in">b_search</span>(matrix, xm+<span class="number">1</span>, y1, x2, ym, target)) ||</span><br><span class="line">        (x2&gt;xm &amp;&amp; y2&gt;ym &amp;&amp; <span class="built_in">b_search</span>(matrix, xm+<span class="number">1</span>, ym+<span class="number">1</span>, x2, y2, target))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x = matrix.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> y = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">b_search</span>(matrix, <span class="number">0</span>, <span class="number">0</span>, x, y, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 581. 最短无序连续子数组</title>
    <url>/posts/shortest-unsorted-continuous-subarray/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/">581. 最短无序连续子数组</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<span id="more"></span>
<h3 id="思路">思路</h3>
<p>todo</p>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> o = nums;</span><br><span class="line">    std::<span class="built_in">sort</span>(o.<span class="built_in">begin</span>(), o.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; l&lt;o.<span class="built_in">size</span>(); ++l) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o[l] != nums[l]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> r = o.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; r&gt;=<span class="number">0</span>; --r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o[r] != nums[r]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r &lt; l ? <span class="number">0</span>: r - l + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mn = nums[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">int</span> mx = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt;= mx) &#123;</span><br><span class="line">            mx = nums[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[n<span class="number">-1</span>-i] &lt;= mn) &#123;</span><br><span class="line">            mn = nums[n<span class="number">-1</span>-i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = n - <span class="number">1</span> - i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r - l + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1470. 重新排列数组</title>
    <url>/posts/shuffle-the-array/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode.cn/problems/shuffle-the-array/">1470. 重新排列数组</a>  难度: <span style="color: rgba(90, 183, 38, 1);">简单</span></p>
<p>给你一个数组 nums ，数组中有 2n 个元素，按 [x1,x2,...,xn,y1,y2,...,yn] 的格式排列。</p>
<p>请你将数组按 [x1,y1,x2,y2,...,xn,yn] 格式重新排列，返回重排后的数组。 <span id="more"></span></p>
<h3 id="题解">题解</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">shuffle</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">        ans[i*<span class="number">2</span>] = nums[i];</span><br><span class="line">        ans[i*<span class="number">2</span>+<span class="number">1</span>] = nums[i+n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 03. 数组中重复的数字</title>
    <url>/posts/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">03. 数组中重复的数字</a>  难度: <span style="color: rgba(90, 183, 38, 1);">简单</span></p>
<p>找出数组中重复的数字。 <span id="more"></span></p>
<p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<h3 id="题解">题解</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (nums[i] != i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[nums[i]]) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            std::<span class="built_in">swap</span>(nums[i], nums[nums[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 137. 只出现一次的数字 II</title>
    <url>/posts/single-number-ii/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode.cn/problems/single-number-ii/">137. 只出现一次的数字 II</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。 <span id="more"></span></p>
<h3 id="题解">题解</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            cnt += (num &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cnt % <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            ans = ans | (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 75. 颜色分类</title>
    <url>/posts/sort-colors/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode.cn/problems/sort-colors/">75. 颜色分类</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<p>必须在不使用库的sort函数的情况下解决这个问题。 <span id="more"></span></p>
<h3 id="题解">题解</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 统计排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        ++cnt[nums[i]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> r_end = cnt[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> w_end = cnt[<span class="number">0</span>] + cnt[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; r_end) &#123;</span><br><span class="line">            nums[i] = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; w_end) &#123;</span><br><span class="line">            nums[i] = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums[i] = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> e = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=e;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == <span class="number">2</span>) &#123; <span class="comment">// 2交换时不需要更新i，因为交换过来的可能是0</span></span><br><span class="line">            std::<span class="built_in">swap</span>(nums[i], nums[e--]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                std::<span class="built_in">swap</span>(nums[i], nums[s++]);</span><br><span class="line">            &#125;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>统计排序</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 136. 只出现一次的数字</title>
    <url>/posts/single-number/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/single-number/">136. 只出现一次的数字</a>  难度: <span style="color: rgba(90, 183, 38, 1);">简单</span></p>
<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<span id="more"></span>
<p><strong>说明：</strong></p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<h3 id="思路">思路</h3>
<h4 id="哈希表">哈希表</h4>
<p>遍历中 <code>std::unordered_map</code> 统计每个元素出现的次数，再遍历一遍统计出现一次的元素。时间复杂度 <span class="math inline">\(O(1)\)</span>，空间复杂度 <span class="math inline">\(O(n)\)</span></p>
<h4 id="差值">差值</h4>
<p>遍历一次求和 <code>sum_v</code>，并插入到<code>std::unordered_set</code> <code>s</code>，对 <code>s</code> 求和 <code>sum_s</code>。那么，出现一次的元素为：<span class="math inline">\(sum_s*2-sum_v\)</span></p>
<h4 id="位运算">位运算</h4>
<p>那些出现2次元素每一位二进制位1的个数是偶数个，所以按位异或后为0，剩下的就是出现一次的元素。</p>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    std::for_each(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [&amp;](<span class="keyword">const</span> <span class="keyword">int</span>&amp; n) &#123;</span><br><span class="line">        ans ^= n;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="知识">知识</h3>
<p><strong>std::for_each</strong><br />
Unlike the rest of the parallel algorithms, for_each <strong>is not allowed to make copies</strong> of the elements in the sequence even if they are trivially copyable.</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 148. 排序链表</title>
    <url>/posts/sort-list/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/sort-list/">148. 排序链表</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给你链表的头结点 <code>head</code> ，请将其按 <code>升序</code> 排列并返回 <code>排序后的链表</code> 。 <span id="more"></span></p>
<p><strong>进阶：</strong></p>
<p>你可以在 <code>O(nlogn)</code> 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</p>
<h3 id="思路">思路</h3>
<p>排序中时间复杂度为<code>O(nlogn)</code>有：快排、堆排、归并排序。其中，归并排序在链表场景较容易实现。</p>
<p>本文采用非递归2路归并实现，也就是自底向上，依次合并2、4、8、...个元素。在每次合并时，由于链表当前区间存在前驱和后继，合并排序当前区间的首尾节点可能会被打乱。</p>
<ul>
<li>对于首节点，复制一个相同节点参与排序，排序结束替换回原来的，保证前驱不变。</li>
<li>对于尾节点，记录其后继，排序结束后赋值给尾节点 <code>next</code> 指针。</li>
</ul>
<p>其中，两个有序链表的合并参考 <a href="/posts/merge-two-sorted-lists/">21. 合并两个有序链表</a></p>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> merge = [<span class="keyword">this</span>](ListNode* l, <span class="keyword">int</span> len) &#123;</span><br><span class="line">        <span class="comment">// 首尾标记</span></span><br><span class="line">        ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(l-&gt;val, l-&gt;next);</span><br><span class="line">        </span><br><span class="line">        ListNode* tail = head;</span><br><span class="line">        ListNode* l1 = head;</span><br><span class="line">        ListNode* l2 = head;</span><br><span class="line">        <span class="keyword">int</span> harf = len / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前半段尾节点和l2</span></span><br><span class="line">        <span class="keyword">while</span> (i++ &lt; harf &amp;&amp; tail) &#123;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tail) &#123;</span><br><span class="line">            <span class="keyword">auto</span> tmp = tail;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">            tmp-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        l2 = tail;</span><br><span class="line">        <span class="keyword">while</span> (i++ &lt; len &amp;&amp; tail) &#123;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tail) &#123;</span><br><span class="line">            <span class="keyword">auto</span> tmp = tail;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">            tmp-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用于合并的虚节点</span></span><br><span class="line">        ListNode dummy;</span><br><span class="line">        ListNode* hand = &amp;dummy;</span><br><span class="line">        ListNode* cur = hand;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">            <span class="keyword">auto</span>&amp; n = l1-&gt;val &lt; l2-&gt;val ? l1 : l2;</span><br><span class="line">            cur-&gt;next = n;</span><br><span class="line">            cur = n;</span><br><span class="line">            n = n-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        l1 = l1 ? l1 : l2;</span><br><span class="line">        cur-&gt;next = l1;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到尾节点</span></span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 还原首节点和尾节点的后继</span></span><br><span class="line">        l-&gt;val = hand-&gt;next-&gt;val;</span><br><span class="line">        l-&gt;next = hand-&gt;next-&gt;next;</span><br><span class="line">        cur-&gt;next = tail;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> hand-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> tail;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算长度</span></span><br><span class="line">    ListNode* l = head;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l) &#123;</span><br><span class="line">        l = l-&gt;next;</span><br><span class="line">        ++n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 归并排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> step=<span class="number">2</span>;; step*=<span class="number">2</span>) &#123;</span><br><span class="line">        l = head;</span><br><span class="line">        <span class="keyword">while</span> (l) &#123;</span><br><span class="line">            l = <span class="built_in">merge</span>(l, step);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (step &gt;= n) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>链表</tag>
        <tag>链表合并</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 206. 反转链表</title>
    <url>/posts/reverse-linked-list/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a> 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="keyword">int</span> value) : <span class="built_in">val</span>(value), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseLink</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode l; <span class="comment">// 避免对第一个节点的特殊处理</span></span><br><span class="line">    ListNode* p;</span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">        p = head-&gt;next;</span><br><span class="line">        head-&gt;next = l.next;</span><br><span class="line">        l.next = head;</span><br><span class="line">        head = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> l.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseLink</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A -&gt; B -&gt; C -&gt; D</span></span><br><span class="line">    <span class="comment">// p1: B -&gt; ...  p2: A -&gt; C -&gt; D</span></span><br><span class="line">    ListNode* p1 = head;</span><br><span class="line">    ListNode* p2 = head-&gt;next;</span><br><span class="line">    p1-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (p2) &#123;</span><br><span class="line">        ListNode* tmp = p2-&gt;next;</span><br><span class="line">        p2-&gt;next = p1;</span><br><span class="line">        p1 = p2;</span><br><span class="line">        p2 = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;ListNode&gt; v = &#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">    ListNode* head = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;v.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i==<span class="number">0</span>) &#123;</span><br><span class="line">            head = &amp;v[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            v[i<span class="number">-1</span>].next = &amp;v[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    head = <span class="built_in">reverseLink</span>(head);</span><br><span class="line">    <span class="keyword">while</span>(head) &#123;</span><br><span class="line">        std::cout &lt;&lt; head-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 621. 任务调度器</title>
    <url>/posts/task-scheduler/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/task-scheduler/">621. 任务调度器</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给你一个用字符数组 <code>tasks</code> 表示的 <code>CPU</code> 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 <code>1</code> 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。 <span id="more"></span></p>
<p>然而，两个 <code>相同种类</code> 的任务之间必须有长度为整数 <code>n</code> 的冷却时间，因此至少有连续 <code>n</code> 个单位时间内 <code>CPU</code> 在执行不同的任务，或者在待命状态。</p>
<p>你需要计算完成所有任务所需要的 <code>最短时间</code> 。</p>
<h3 id="思路">思路</h3>
<p>统计每种任务个数。其中，最多任务个数记作 <code>i</code>，大于等于 <code>i</code> 的任务种类有 <code>j</code> 个。</p>
<p>如果，任务个数少于 <code>(i-1）* (n+1)</code>。构建一个 <code>(i-1) * (n+1)</code> 的矩阵，矩阵的 <code>1 ~ j</code> 列排任务数等于 <code>i</code> 的 <code>j</code> 个任务，第 <code>i</code> 行排 <code>j</code> 个任务，这样总的时间是 <code>(i-1) * (n+1) + j</code>。</p>
<p>如果，任务个数大于 <code>(i-1）* (n+1)</code>。将 <code>(i-1）* (n+1)</code> 还是按上面的排，对于另外的任务直接排列在i-1行的任意行后面即可，这样总的时间是 任务的个数。</p>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(vector&lt;<span class="keyword">char</span>&gt;&amp; tasks, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 统计每种任务数，其中最大任务数为i，&gt;=i的任务数有j个</span></span><br><span class="line">    <span class="comment">// 构建矩阵 (i-1) * (n+1)</span></span><br><span class="line">    <span class="comment">// a = (i-1) * (n+1) + j，没有排满矩阵</span></span><br><span class="line">    <span class="comment">// b = tasks.size()，排满矩阵，在i-1行后面插入其他任务</span></span><br><span class="line">    <span class="comment">// std::max(a, b)，选择a说明有间隙, 选择b说明没有间隙</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">m</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c: tasks) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = c - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        i = std::<span class="built_in">max</span>(i, ++m[k]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v: m) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v == i) &#123;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = (i<span class="number">-1</span>) * (n+<span class="number">1</span>) + j;</span><br><span class="line">    <span class="keyword">int</span> b = tasks.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">max</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>贪心</tag>
        <tag>抵消法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 560. 和为 K 的子数组</title>
    <url>/posts/subarray-sum-equals-k/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">560. 和为 K 的子数组</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给你一个整数数组 nums 和一个整数 k ，请你统计并返回该数组中和为 k 的连续子数组的个数。 <span id="more"></span></p>
<h3 id="题解">题解</h3>
<h4 id="dfs">dfs</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> sum, <span class="keyword">int</span> next, <span class="keyword">int</span>&amp; count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (next &gt;= nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(nums, sum+nums[next], next+<span class="number">1</span>, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(nums, -k+nums[i], i+<span class="number">1</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="前缀和">前缀和</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">sums</span><span class="params">(nums.size()+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    sums[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;sums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        sums[i] = nums[i<span class="number">-1</span>] + sums[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;sums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;sums.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sums[j] - sums[i] == k) &#123;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="前缀和hash">前缀和+hash</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    std::unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; sum2count = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> it = sum2count.<span class="built_in">find</span>(sum - k);</span><br><span class="line">        <span class="keyword">if</span> (it != sum2count.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            total += it-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        it = sum2count.<span class="built_in">find</span>(sum);</span><br><span class="line">        <span class="keyword">if</span> (it == sum2count.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            sum2count.<span class="built_in">insert</span>(&#123;sum, <span class="number">1</span>&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ++it-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>dfs</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 347. 前 K 个高频元素</title>
    <url>/posts/top-k-frequent-elements/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<span id="more"></span>
<h3 id="思路">思路</h3>
<p>todo <a href="https://algs4.cs.princeton.edu/lectures/demo/23DemoQuickSelect.pdf">QuickSelect</a></p>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(std::vector&lt;std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 可随机选择基准，以使得每次尽量均分</span></span><br><span class="line">        <span class="keyword">int</span> lower_bound = l;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=l; i&lt;r; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i].second &lt; nums[r].second) &#123;</span><br><span class="line">                std::<span class="built_in">swap</span>(nums[i], nums[lower_bound]);</span><br><span class="line">                ++lower_bound;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::<span class="built_in">swap</span>(nums[lower_bound], nums[r]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> lower_bound;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quick_select</span><span class="params">(std::vector&lt;std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = <span class="built_in">partition</span>(nums, l, r);</span><br><span class="line">        <span class="keyword">if</span> (m == t) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m &lt; t) &#123;</span><br><span class="line">            <span class="built_in">quick_select</span>(nums, m+<span class="number">1</span>, r, t);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">quick_select</span>(nums, l, m<span class="number">-1</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        std::unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num: nums) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = cnt.<span class="built_in">find</span>(num);</span><br><span class="line">            <span class="keyword">if</span> (it == cnt.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                cnt.<span class="built_in">insert</span>(&#123;num, <span class="number">1</span>&#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++it-&gt;second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::vector&lt;std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; pairs;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> kv: cnt) &#123;</span><br><span class="line">            pairs.<span class="built_in">push_back</span>(&#123;kv.first, kv.second&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">quick_select</span>(pairs, <span class="number">0</span>, pairs.<span class="built_in">size</span>()<span class="number">-1</span>, pairs.<span class="built_in">size</span>()-k);</span><br><span class="line"></span><br><span class="line">        std::vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=pairs.<span class="built_in">size</span>()-k; i&lt;pairs.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(pairs[i].first);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>hash</tag>
        <tag>快排</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1226. 哲学家进餐</title>
    <url>/posts/the-dining-philosophers/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode.cn/problems/the-dining-philosophers/">1226. 哲学家进餐</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>5 个沉默寡言的哲学家围坐在圆桌前，每人面前一盘意面。叉子放在哲学家之间的桌面上。（5 个哲学家，5 根叉子）</p>
<p>所有的哲学家都只会在思考和进餐两种行为间交替。哲学家只有同时拿到左边和右边的叉子才能吃到面，而同一根叉子在同一时间只能被一个哲学家使用。每个哲学家吃完面后都需要把叉子放回桌面以供其他哲学家吃面。只要条件允许，哲学家可以拿起左边或者右边的叉子，但在没有同时拿到左右叉子时不能进食。 <span id="more"></span></p>
<p>假设面的数量没有限制，哲学家也能随便吃，不需要考虑吃不吃得下。</p>
<p>设计一个进餐规则（并行算法）使得每个哲学家都不会挨饿；也就是说，在没有人知道别人什么时候想吃东西或思考的情况下，每个哲学家都可以在吃饭和思考之间一直交替下去。</p>
<h3 id="题解">题解</h3>
<p>破坏环路等待条件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiningPhilosophers</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DiningPhilosophers</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wantsToEat</span><span class="params">(<span class="keyword">int</span> philosopher,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="keyword">void</span>()&gt; pickLeftFork,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="keyword">void</span>()&gt; pickRightFork,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="keyword">void</span>()&gt; eat,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="keyword">void</span>()&gt; putLeftFork,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="keyword">void</span>()&gt; putRightFork)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l_fork = philosopher;</span><br><span class="line">        <span class="keyword">int</span> r_fork = (philosopher + <span class="number">1</span>) % <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l_fork == <span class="number">0</span>) &#123;</span><br><span class="line">            std::<span class="built_in">swap</span>(l_fork, r_fork);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">l1</span><span class="params">(_mutex[l_fork])</span></span>;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">l2</span><span class="params">(_mutex[r_fork])</span></span>;</span><br><span class="line">        <span class="built_in">pickRightFork</span>();</span><br><span class="line">        <span class="built_in">pickLeftFork</span>();</span><br><span class="line">        <span class="built_in">eat</span>();</span><br><span class="line">        <span class="built_in">putLeftFork</span>();</span><br><span class="line">        <span class="built_in">putRightFork</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::mutex&gt; _mutex = std::vector&lt;std::mutex&gt;(<span class="number">5</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 195. 第十行</title>
    <url>/posts/tenth-line/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode.cn/problems/tenth-line/">195. 第十行</a>  难度: <span style="color: rgba(90, 183, 38, 1);">简单</span></p>
<p>给定一个文本文件 file.txt，请只打印这个文件中的第十行。 <span id="more"></span></p>
<h3 id="题解">题解</h3>
<h4 id="方法1">方法1</h4>
<p><code>sed -n 10p file.txt</code></p>
<h4 id="方法2">方法2</h4>
<p><code>awk NR==10 file.txt</code></p>
<h4 id="方法3">方法3</h4>
<p><code>tail -n+10 file.txt | head -n 1</code></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>不同路径</title>
    <url>/posts/unique-paths/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/unique-paths/">62. 不同路径</a> 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。<br />
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。<br />
问总共有多少条不同的路径？</p>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m &lt; <span class="number">1</span> || n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;m; ++i) &#123;</span><br><span class="line">        dp[i].<span class="built_in">resize</span>(n);</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">1</span>; i&lt;m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> j=<span class="number">1</span>; j&lt;n; ++j) &#123;</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">uniquePaths</span>(<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 593. 有效的正方形</title>
    <url>/posts/valid-square/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode.cn/problems/valid-square/">593. 有效的正方形</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给定2D空间中四个点的坐标 p1, p2, p3 和 p4，如果这四个点构成一个正方形，则返回 true 。 <span id="more"></span></p>
<p>点的坐标 pi 表示为 [xi, yi] 。 输入没有任何顺序 。</p>
<p>一个 有效的正方形 有四条等边和四个等角(90度角)。</p>
<h3 id="题解">题解</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">validSquare</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; p1, vector&lt;<span class="keyword">int</span>&gt;&amp; p2, vector&lt;<span class="keyword">int</span>&gt;&amp; p3, vector&lt;<span class="keyword">int</span>&gt;&amp; p4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> len = [](vector&lt;<span class="keyword">int</span>&gt;&amp; p1, vector&lt;<span class="keyword">int</span>&gt;&amp; p2) &#123;</span><br><span class="line">        <span class="keyword">int</span> d1 = p1[<span class="number">0</span>] - p2[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> d2 = p1[<span class="number">1</span>] - p2[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> d1 * d1 + d2 * d2;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::unordered_set&lt;<span class="keyword">int</span>&gt; lens&#123;</span><br><span class="line">        <span class="built_in">len</span>(p1, p2),</span><br><span class="line">        <span class="built_in">len</span>(p1, p3),</span><br><span class="line">        <span class="built_in">len</span>(p1, p4),</span><br><span class="line">        <span class="built_in">len</span>(p2, p3),</span><br><span class="line">        <span class="built_in">len</span>(p2, p4),</span><br><span class="line">        <span class="built_in">len</span>(p3, p4)&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lens.<span class="built_in">size</span>() == <span class="number">2</span> &amp;&amp; lens.<span class="built_in">find</span>(<span class="number">0</span>) == lens.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 面试题 17.01. 不用加号的加法</title>
    <url>/posts/add-without-plus-lcci/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode.cn/problems/add-without-plus-lcci/">面试题 17.01. 不用加号的加法</a>  难度: <span style="color: rgba(90, 183, 38, 1);">简单</span></p>
<p>设计一个函数把两个数字相加。不得使用 + 或者其他算术运算符。 <span id="more"></span></p>
<h3 id="思路">思路</h3>
<p><code>a ^ b</code> 无进位加<br />
<code>a &amp; b</code> 进位位置1</p>
<p>在计算机中负数是以补码的形式表示的：<br />
1.解决0的符号问题<br />
2.减法转换为加法运算</p>
<h3 id="题解">题解</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> carry = a &amp; b;</span><br><span class="line">        a = a ^ b;</span><br><span class="line">        b = carry &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/posts/union-find/</url>
    <content><![CDATA[<p>并查集（Disjoint-set data structure）是一种数据结构，可高效对关系集合进行查询、合并。 <span id="more"></span></p>
<h3 id="算法">算法</h3>
<h4 id="表示">表示</h4>
<p>每个集合用一棵树表示，每个节点保存父节点引用，根节点的引用是自己，初始化时所有节点都引用自己。可以用数组来表示树结构。</p>
<h4 id="查找">查找</h4>
<p>不断的查找父节点引用，直到根节点。接口：<code>int find(int i);</code></p>
<h5 id="路径压缩">路径压缩</h5>
<p>查找的时间复杂度取决于树的深度，可以把树的深度进行压缩。在查找中将子节点挂在<code>父节点的父节点</code>以实现压缩。</p>
<h4 id="合并">合并</h4>
<p>调用接口 <code>void unions(int i, int j);</code> 进行合并。只需要查找到<code>i</code>的根节点<code>p</code>，<code>j</code>的根节点<code>q</code>，将<code>p</code>的根节点更新为<code>q</code>即可完成合并。</p>
<h5 id="带权重路径">带权重路径</h5>
<p>上面的合并方法可能使得合并后的树极其不均衡，增大树深度，从而增加查询的耗时。我们可以在合并时选择较小树挂在较大树的根节点，具体实现：对每个节点维护一个权重，并在合并中不断更新。</p>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        id.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">            id[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sz.<span class="built_in">resize</span>(n, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unions</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        i = <span class="built_in">find</span>(i);</span><br><span class="line">        j = <span class="built_in">find</span>(j);</span><br><span class="line">        <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sz[i] &gt; sz[j]) &#123; <span class="comment">// 路径权重</span></span><br><span class="line">            std::<span class="built_in">swap</span>(i, j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        id[i] = j;</span><br><span class="line">        sz[j] += sz[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i != id[i]) &#123;</span><br><span class="line">            id[i] = id[id[i]]; <span class="comment">// 路径压缩</span></span><br><span class="line">            i = id[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(i) == <span class="built_in">find</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; id;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; sz;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="参考">参考</h3>
<blockquote>
<p>1.<a href="https://algs4.cs.princeton.edu/lectures/keynote/15UnionFind.pdf">普林斯顿讲义:Union–Find.</a><br />
2.<a href="https://zh.wikipedia.org/wiki/%E5%B9%B6%E6%9F%A5%E9%9B%86">维基百科:并查集</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 98. 验证二叉搜索树</title>
    <url>/posts/validate-binary-search-tree/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。 <span id="more"></span></p>
<p>有效 二叉搜索树定义如下：</p>
<p>节点的左子树只包含 小于 当前节点的数。 节点的右子树只包含 大于 当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。</p>
<h3 id="题解">题解</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isValidBST</span>(root-&gt;left)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt;= pre_val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre_val = root-&gt;val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isValidBST</span>(root-&gt;right)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> pre_val = std::numeric_limits&lt;<span class="keyword">int64_t</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 79. 单词搜索</title>
    <url>/posts/word-search/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode.cn/problems/word-search/">79. 单词搜索</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 <span id="more"></span></p>
<h3 id="题解">题解</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> i, <span class="keyword">int</span> j, std::string&amp; word, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// k遍历完说明 已经找到所有字符</span></span><br><span class="line">        <span class="keyword">if</span> (k &gt;= word.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 边界条件</span></span><br><span class="line">        <span class="keyword">if</span> (i&gt;=board.<span class="built_in">size</span>() || j&gt;=board[i].<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历过的，不能重复使用</span></span><br><span class="line">        <span class="keyword">if</span> (board[i][j] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遇到不符合的</span></span><br><span class="line">        <span class="keyword">if</span> (board[i][j] != word[k]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 状态标记为遍历过</span></span><br><span class="line">        board[i][j] = -board[i][j];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4个方向深度遍历</span></span><br><span class="line">        ++k;</span><br><span class="line">        <span class="keyword">bool</span> x = <span class="built_in">dfs</span>(board, i<span class="number">-1</span>, j, word, k) || <span class="built_in">dfs</span>(board, i+<span class="number">1</span>, j, word, k) \</span><br><span class="line">            || <span class="built_in">dfs</span>(board, i, j<span class="number">-1</span>, word, k) || <span class="built_in">dfs</span>(board, i, j+<span class="number">1</span>, word, k);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回溯时恢复状态</span></span><br><span class="line">        board[i][j] = -board[i][j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;board.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;board[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">dfs</span>(board, i, j, word, <span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 192. 统计词频</title>
    <url>/posts/word-frequency/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode.cn/problems/word-frequency/">192. 统计词频</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>写一个 bash 脚本以统计一个文本文件 words.txt 中每个单词出现的频率。</p>
<p>为了简单起见，你可以假设：</p>
<p>words.txt只包括小写字母和 ' ' 。 每个单词只由小写字母组成。 单词间由一个或多个空格字符分隔。</p>
<span id="more"></span>
<h3 id="题解">题解</h3>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Read from the file words.txt and output the word frequency list to stdout.</span></span><br><span class="line"></span><br><span class="line">cat words.txt | tr -s <span class="string">&#x27; &#x27;</span> <span class="string">&#x27;\n&#x27;</span> | sort | uniq -c | sort -nr | awk <span class="string">&#x27;&#123;print $2, $1&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 494. 目标和</title>
    <url>/posts/target-sum/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/target-sum/">LeetCode 494. 目标和</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给你一个整数数组 nums 和一个整数 target 。 <span id="more"></span></p>
<p>向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：</p>
<p>例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1" 。 返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。</p>
<h3 id="思路">思路</h3>
<h4 id="深度优先">深度优先</h4>
<p>根据题目描述直接遍历，从左往右，后一步骤是在前一步的基础上，每个步骤分为两种情况。本质是一棵二叉树的遍历，采用深度优先遍历到叶子节点如果路径和为target，则数目增1。</p>
<ul>
<li>时间复杂度O(2^n)。二叉树的深度为数组长度n，所有节点都需要遍历，因此节点数代表了时间复杂度。</li>
<li>空间复杂度O(n)。空间复杂度取决于递归调用的栈空间，栈深度为数组长度n。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target, <span class="keyword">int</span> index, <span class="keyword">int</span>&amp; count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(nums, target+nums[index], index+<span class="number">1</span>, count);</span><br><span class="line">    <span class="built_in">dfs</span>(nums, target-nums[index], index+<span class="number">1</span>, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(nums,  -target, <span class="number">0</span>, count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="动态规划">动态规划</h4>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 139. 单词拆分</title>
    <url>/posts/word-break/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/word-break/">139. 单词拆分</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。</p>
<p>注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p>
<span id="more"></span>
<h3 id="题解">题解</h3>
<h4 id="dfs">dfs</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(string&amp; s, std::unordered_set&lt;std::string&gt; set, <span class="keyword">int</span> pos, <span class="keyword">int</span> len, std::unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt;&amp; cache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos + len &gt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = cache.<span class="built_in">find</span>(pos &lt;&lt; <span class="number">16</span> | len);</span><br><span class="line">    <span class="keyword">if</span> (it != cache.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (set.<span class="built_in">count</span>(s.<span class="built_in">substr</span>(pos, len)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos+len == s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = <span class="built_in">dfs</span>(s, set, pos+len, <span class="number">1</span>, cache) || <span class="built_in">dfs</span>(s, set, pos, len+<span class="number">1</span>, cache);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ret = <span class="built_in">dfs</span>(s, set, pos, len+<span class="number">1</span>, cache);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cache.<span class="built_in">insert</span>(&#123;pos &lt;&lt; <span class="number">16</span> | len, ret&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unordered_set&lt;std::string&gt; <span class="title">set</span><span class="params">(wordDict.begin(), wordDict.end())</span></span>;</span><br><span class="line">    std::unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; cache;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(s, set, <span class="number">0</span>, <span class="number">1</span>, cache);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="动态规划">动态规划</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unordered_set&lt;std::string&gt; <span class="title">set</span><span class="params">(wordDict.begin(), wordDict.end())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(s.size()+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[j] == <span class="number">1</span> &amp;&amp; set.<span class="built_in">count</span>(s.<span class="built_in">substr</span>(j, i-j)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 309. 最佳买卖股票时机含冷冻期</title>
    <url>/posts/best-time-to-buy-and-sell-stock-with-cooldown/</url>
    <content><![CDATA[<h3 id="题目">题目</h3>
<p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 最佳买卖股票时机含冷冻期</a> 难度: <span style="color: rgba(255, 161, 25, 1);">中等</span></p>
<p>给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。​</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: <span id="more"></span></p>
<p>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<h3 id="题解">题解</h3>
<h4 id="表示">表示</h4>
<p>本来应该存在两种状态(status)：未持有股票(s_empty)，持有股票(s_hold)。 <img data-src="https://s1.ax1x.com/2022/10/09/xJqIzV.png" width="50%"></p>
<p>题目要求存在冷冻期，也就是不允许s_hold → s_empty → s_hold。因此，引入第三种状态s_sell，表示卖出（前一天）未持有（今天）；而s_empty表示当天未持有且前一天也未持有。状态之间的转移关系： <img data-src="https://s1.ax1x.com/2022/10/09/xJq5R0.png" width="50%"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s_empty → s_hold → s_sell → s_empty</span><br><span class="line">s_empty → s_empty</span><br><span class="line">s_hold → s_hold</span><br></pre></td></tr></table></figure>
<p>3种状态由3个变量表示：s_empty → s_hold → s_sell，每个变量的值代表这种状态下的收益。</p>
<h4 id="初始">初始</h4>
<p>对于第1天： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s_empy = <span class="number">0</span></span><br><span class="line">s_hold = -prices[<span class="number">0</span>]</span><br><span class="line">s_sell = <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<h4 id="迭代">迭代</h4>
<p>对于第i天： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">new_s_empty = <span class="built_in">max</span>(s_empty, s_sell)</span><br><span class="line">new_s_hold = <span class="built_in">max</span>(s_hold, s_empty - prices[i])</span><br><span class="line">new_s_sell = s_hold + prices[i]</span><br><span class="line"></span><br><span class="line">s_empty = new_s_empty</span><br><span class="line">s_hold = new_s_hold</span><br><span class="line">s_sell = new_s_sell</span><br></pre></td></tr></table></figure></p>
<h4 id="返回">返回</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">max</span>(s_empty, s_sell)</span><br></pre></td></tr></table></figure>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices.<span class="built_in">size</span>() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> s_empty = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> s_hold = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> s_sell = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> new_s_empty = std::<span class="built_in">max</span>(s_empty, s_sell);</span><br><span class="line">        <span class="keyword">int</span> new_s_hold = std::<span class="built_in">max</span>(s_hold, s_empty - prices[i]);</span><br><span class="line">        <span class="keyword">int</span> new_s_sell = s_hold + prices[i];</span><br><span class="line"></span><br><span class="line">        s_empty = new_s_empty;</span><br><span class="line">        s_hold = new_s_hold;</span><br><span class="line">        s_sell = new_s_sell;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">max</span>(s_empty, s_sell);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>买卖股票</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
</search>
